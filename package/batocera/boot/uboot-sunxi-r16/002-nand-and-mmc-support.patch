diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/arch/arm/cpu/armv7/sun8iw5/mmc/mmc_bsp.c patched_uboot-sunxi-r16/arch/arm/cpu/armv7/sun8iw5/mmc/mmc_bsp.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/arch/arm/cpu/armv7/sun8iw5/mmc/mmc_bsp.c	2022-10-07 03:35:16.000000000 +0000
+++ patched_uboot-sunxi-r16/arch/arm/cpu/armv7/sun8iw5/mmc/mmc_bsp.c	2022-10-17 14:24:12.073860400 +0000
@@ -97,6 +97,7 @@
 	struct sunxi_mmc_host* mmchost = &mmc_host[sdc_no];
 
 	mmcdbg("init mmc %d resource\n", sdc_no);
+        mmcinfo("mmc %d resource init start...\n",sdc_no);
 	mmchost->reg = (struct sunxi_mmc *)(MMC_REG_BASE + sdc_no * 0x1000);
 	mmchost->database = (u32)mmchost->reg + MMC_REG_FIFO_OS;
 
@@ -531,6 +532,7 @@
 	unsigned int status = 0;
 	unsigned int usedma = 0;
 	unsigned int bytecnt = 0;
+        mmcinfo("mmc %d sending cmd from mmc_send_cmd in mmc_bsp.c...\n",mmchost ->mmc_no);
 
 	if (mmchost->fatal_err){
 		mmcinfo("mmc %d Found fatal err,so no send cmd\n",mmchost ->mmc_no);
@@ -625,6 +627,7 @@
 			if(!error)
 				error = 0xffffffff;//represet software timeout
 			mmcinfo("mmc %d cmd %d err %x\n",mmchost ->mmc_no, cmd->cmdidx, error);
+                        mmcinfo("failed at readl(&mmchost->reg->rint)");
 			goto out;
 		}
 	} while (!(status&0x4));
@@ -775,7 +778,7 @@
 	mmc->control_num = sdc_no;
 
 
-    mmc_host[sdc_no].pdes = (struct sunxi_mmc_des*)DMAC_DES_BASE_IN_SDRAM;
+        mmc_host[sdc_no].pdes = (struct sunxi_mmc_des*)DMAC_DES_BASE_IN_SDRAM;
 	if (mmc_resource_init(sdc_no)){
 		mmcinfo("mmc %d resource init failed\n",sdc_no);
 		return -1;
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/arch/arm/cpu/armv7/sun8iw5/mmc/mmc.c patched_uboot-sunxi-r16/arch/arm/cpu/armv7/sun8iw5/mmc/mmc.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/arch/arm/cpu/armv7/sun8iw5/mmc/mmc.c	2022-10-07 03:35:16.000000000 +0000
+++ patched_uboot-sunxi-r16/arch/arm/cpu/armv7/sun8iw5/mmc/mmc.c	2022-10-17 14:24:58.993717093 +0000
@@ -1362,8 +1362,10 @@
 {
 	mmc_devices[dev_num] = mmc;
 
-	if (!mmc->b_max)
+	if (!mmc->b_max){
 		mmc->b_max = CONFIG_SYS_MMC_MAX_BLK_COUNT;
+                mmcinfo("mmc->b_max new val: %d\n",mmc->b_max);
+        }
 
 	return mmc_init(mmc);
 }
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/board/sunxi/board_common.c patched_uboot-sunxi-r16/board/sunxi/board_common.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/board/sunxi/board_common.c	2022-10-07 03:35:16.000000000 +0000
+++ patched_uboot-sunxi-r16/board/sunxi/board_common.c	2022-10-17 14:23:28.929991665 +0000
@@ -1675,7 +1675,7 @@
         return 0;
     }
     if(!script_parser_fetch("platform", "debug_mode",&debug_mode, 1))
-        gd->debug_mode = debug_mode;
+        gd->debug_mode = 1;
     else
         gd->debug_mode = 1;
     return 0;
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/boards.cfg patched_uboot-sunxi-r16/boards.cfg
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/boards.cfg	2022-10-07 03:35:16.000000000 +0000
+++ patched_uboot-sunxi-r16/boards.cfg	2022-10-19 16:54:41.171475785 +0000
@@ -196,6 +196,7 @@
 sun8iw3p1					 arm	     armv7	     sun8iw3		     sunxi	        sun8iw3
 sun8iw5p1					 arm	     armv7	     sun8iw5		     sunxi	        sun8iw5
 sun8iw5p1_nor					 arm	     armv7	     sun8iw5		     sunxi	        sun8iw5
+sun8iw5p1_memboot					 arm	     armv7	     sun8iw5		     sunxi	        sun8iw5
 
 sun8iw6p1					 arm	     armv7	     sun8iw6		     sunxi	        sun8iw6
 sun8iw7p1                                        arm         armv7           sun8iw7                 sunxi              sun8iw7
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/common/cmd_bootm.c patched_uboot-sunxi-r16/common/cmd_bootm.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/common/cmd_bootm.c	2022-10-07 03:35:16.000000000 +0000
+++ patched_uboot-sunxi-r16/common/cmd_bootm.c	2022-10-17 14:23:08.334054146 +0000
@@ -21,6 +21,7 @@
  * MA 02111-1307 USA
  */
 
+#define DEBUG
 
 /*
  * Boot support
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/common/cmd_mmc.c patched_uboot-sunxi-r16/common/cmd_mmc.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/common/cmd_mmc.c	2022-10-07 03:35:16.000000000 +0000
+++ patched_uboot-sunxi-r16/common/cmd_mmc.c	2022-10-17 14:23:02.698071227 +0000
@@ -23,6 +23,7 @@
 
 #include <common.h>
 #include <command.h>
+
 #include <mmc.h>
 
 #ifndef CONFIG_GENERIC_MMC
@@ -172,11 +173,11 @@
 	}
 */
 	card_no = get_mmc_num();
-	if((card_no != 0) && (card_no != 2))
-	{
-		puts("No MMC device available\n");
-		return 1;
-	}
+	//if((card_no != 0) && (card_no != 2))
+	//{
+	//	puts("No MMC device available\n");
+	//	return 1;
+	//}
 
 	if (strcmp(argv[1], "rescan") == 0) {
 		struct mmc *mmc = find_mmc_device(card_no);
@@ -217,8 +218,11 @@
 		int dev, part = -1;
 		struct mmc *mmc;
 
-		if (argc == 2)
+		if (argc == 2){
 			dev = card_no;
+		    printf("attempting to switch card_no to %d\n",dev);
+			
+		}
 		else if (argc == 3)
 			dev = simple_strtoul(argv[2], NULL, 10);
 		else if (argc == 4) {
@@ -275,50 +279,50 @@
 		state = MMC_INVALID;
 
 	if (state != MMC_INVALID) {
-		struct mmc *mmc = find_mmc_device(card_no);
-		int idx = 2;
-		u32 blk, cnt, n;
-		void *addr;
-
-		if (state != MMC_ERASE) {
-			addr = (void *)simple_strtoul(argv[idx], NULL, 16);
-			++idx;
-		} else
-			addr = 0;
-		blk = simple_strtoul(argv[idx], NULL, 16);
-		cnt = simple_strtoul(argv[idx + 1], NULL, 16);
-
-		if (!mmc) {
-			printf("no mmc device at slot %x\n", card_no);
-			return 1;
-		}
-
-		printf("\nMMC %s: dev # %d, block # %d, count %d ... ",
-				argv[1], card_no, blk, cnt);
-
-		mmc_init(mmc);
-
-		switch (state) {
-		case MMC_READ:
-			n = mmc->block_dev.block_read(card_no, blk,
-						      cnt, addr);
-			/* flush cache after read */
-			flush_cache((ulong)addr, cnt * 512); /* FIXME */
-			break;
-		case MMC_WRITE:
-			n = mmc->block_dev.block_write(card_no, blk,
-						      cnt, addr);
-			break;
-		case MMC_ERASE:
-			n = mmc->block_dev.block_erase(card_no, blk, cnt);
-			break;
-		default:
-			BUG();
-		}
-
-		printf("%d blocks %s: %s\n",
-				n, argv[1], (n == cnt) ? "OK" : "ERROR");
-		return (n == cnt) ? 0 : 1;
+		// struct mmc *mmc = find_mmc_device(card_no);
+		// int idx = 2;
+		// u32 blk, cnt, n;
+		// void *addr;
+
+		// if (state != MMC_ERASE) {
+			// addr = (void *)simple_strtoul(argv[idx], NULL, 16);
+			// ++idx;
+		// } else
+			// addr = 0;
+		// blk = simple_strtoul(argv[idx], NULL, 16);
+		// cnt = simple_strtoul(argv[idx + 1], NULL, 16);
+
+		// if (!mmc) {
+			// printf("no mmc device at slot %x\n", card_no);
+			// return 1;
+		// }
+
+		// printf("\nMMC %s: dev # %d, block # %d, count %d ... ",
+				// argv[1], card_no, blk, cnt);
+
+		// mmc_init(mmc);
+
+		// switch (state) {
+		// case MMC_READ:
+			// n = mmc->block_dev.block_read(card_no, blk,
+						      // cnt, addr);
+			// /* flush cache after read */
+			// flush_cache((ulong)addr, cnt * 512); /* FIXME */
+			// break;
+		// case MMC_WRITE:
+			// n = mmc->block_dev.block_write(card_no, blk,
+						      // cnt, addr);
+			// break;
+		// case MMC_ERASE:
+			// n = mmc->block_dev.block_erase(card_no, blk, cnt);
+			// break;
+		// default:
+			// BUG();
+		// }
+
+		// printf("%d blocks %s: %s\n",
+				// n, argv[1], (n == cnt) ? "OK" : "ERROR");
+		// return (n == cnt) ? 0 : 1;
 	}
 
 	return cmd_usage(cmdtp);
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/common/console.c patched_uboot-sunxi-r16/common/console.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/common/console.c	2022-10-07 03:35:16.000000000 +0000
+++ patched_uboot-sunxi-r16/common/console.c	2022-10-17 14:21:03.582429637 +0000
@@ -550,6 +550,7 @@
 int console_init_f(void)
 {
 	gd->have_console = 1;
+	gd->debug_mode = 1;
 
 #ifdef CONFIG_SILENT_CONSOLE
 	if (getenv("silent") != NULL)
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/common/env_embedded.c patched_uboot-sunxi-r16/common/env_embedded.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/common/env_embedded.c	2022-10-07 03:35:16.000000000 +0000
+++ patched_uboot-sunxi-r16/common/env_embedded.c	2022-10-17 14:20:53.766458942 +0000
@@ -102,6 +102,13 @@
 	1,		/* Flags: valid */
 #endif
 	{
+#if defined(CONFIG_ENV_EMBEDDED_BLANK)
+#define MY_STR_1(str) #str
+#define MY_STRINGIZE(str) MY_STR_1(str)
+	"env_blob_size_incl_header="	MY_STRINGIZE(CONFIG_ENV_SIZE)	"\0"
+#undef MY_STRINGIZE
+#undef MY_STR_1
+#else
 #if defined(CONFIG_BOOTARGS)
 	"bootargs="	CONFIG_BOOTARGS			"\0"
 #endif
@@ -183,6 +190,7 @@
 #ifdef  CONFIG_EXTRA_ENV_SETTINGS
 	CONFIG_EXTRA_ENV_SETTINGS
 #endif
+#endif
 	"\0"		/* Term. env_t.data with 2 NULs */
 	}
 };
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/common/env_flash.c patched_uboot-sunxi-r16/common/env_flash.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/common/env_flash.c	2022-10-07 03:35:16.000000000 +0000
+++ patched_uboot-sunxi-r16/common/env_flash.c	2022-10-17 14:20:36.058511710 +0000
@@ -50,8 +50,8 @@
 
 #ifdef ENV_IS_EMBEDDED
 
-extern uchar environment[];
-env_t *env_ptr = (env_t *)(&environment[0]);
+extern env_t environment;
+env_t *env_ptr = &environment;
 
 static env_t *flash_addr = (env_t *)CONFIG_ENV_ADDR;
 
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/common/env_mmc.c patched_uboot-sunxi-r16/common/env_mmc.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/common/env_mmc.c	2022-10-07 03:35:16.000000000 +0000
+++ patched_uboot-sunxi-r16/common/env_mmc.c	2022-10-17 14:20:30.418528487 +0000
@@ -38,8 +38,8 @@
 char *env_name_spec = "MMC";
 
 #ifdef ENV_IS_EMBEDDED
-extern uchar environment[];
-env_t *env_ptr = (env_t *)(&environment[0]);
+extern env_t environment;
+env_t *env_ptr = &environment;
 #else /* ! ENV_IS_EMBEDDED */
 env_t *env_ptr = NULL;
 #endif /* ENV_IS_EMBEDDED */
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/common/env_nand.c patched_uboot-sunxi-r16/common/env_nand.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/common/env_nand.c	2022-10-07 03:35:16.000000000 +0000
+++ patched_uboot-sunxi-r16/common/env_nand.c	2022-10-17 14:20:24.282546727 +0000
@@ -62,8 +62,8 @@
 
 
 #if defined(ENV_IS_EMBEDDED)
-extern uchar environment[];
-env_t *env_ptr = (env_t *)(&environment[0]);
+extern env_t environment;
+env_t *env_ptr = &environment;
 #elif defined(CONFIG_NAND_ENV_DST)
 env_t *env_ptr = (env_t *)CONFIG_NAND_ENV_DST;
 #else /* ! ENV_IS_EMBEDDED */
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/common/env_onenand.c patched_uboot-sunxi-r16/common/env_onenand.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/common/env_onenand.c	2022-10-07 03:35:16.000000000 +0000
+++ patched_uboot-sunxi-r16/common/env_onenand.c	2022-10-17 14:20:17.326567383 +0000
@@ -48,7 +48,7 @@
 #define ONENAND_ENV_SIZE(mtd)	(ONENAND_MAX_ENV_SIZE - ENV_HEADER_SIZE)
 
 #ifdef ENV_IS_EMBEDDED
-extern uchar environment[];
+extern env_t environment;
 #endif /* ENV_IS_EMBEDDED */
 
 DECLARE_GLOBAL_DATA_PTR;
@@ -67,7 +67,7 @@
 	int rc;
 	size_t retlen;
 #ifdef ENV_IS_EMBEDDED
-	char *buf = (char *)&environment[0];
+	char *buf = (char *)&environment;
 #else
 	loff_t env_addr = CONFIG_ENV_ADDR;
 	char onenand_env[ONENAND_MAX_ENV_SIZE];
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/common/env_sunxi_flash.c patched_uboot-sunxi-r16/common/env_sunxi_flash.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/common/env_sunxi_flash.c	2022-10-07 03:35:16.000000000 +0000
+++ patched_uboot-sunxi-r16/common/env_sunxi_flash.c	2022-10-17 14:20:09.498590609 +0000
@@ -40,8 +40,8 @@
 char * env_name_spec = "SUNXI";
 
 #ifdef ENV_IS_EMBEDDED
-extern uchar environment[];
-env_t *env_ptr = (env_t *)(&environment[0]);
+extern env_t environment;
+env_t *env_ptr = &environment;
 #else /* ! ENV_IS_EMBEDDED */
 env_t *env_ptr = NULL;
 #endif /* ENV_IS_EMBEDDED */
@@ -65,8 +65,12 @@
 #define CONFIG_ENV_OFFSET 0
 #endif
 
+#ifdef ENV_IS_EMBEDDED
+extern size_t env_size;
+#else
 //loff_t env_offset = (loff_t)CONFIG_ENV_ADDR;
 size_t env_size = (size_t)CONFIG_ENV_SIZE;
+#endif
 
 uchar env_get_char_spec(int index)
 {
@@ -153,7 +157,8 @@
 		}
 		env_import(buf, 1);
 	}
-
+#else
+    env_import((char *)&environment, 1);
 #endif
 }
 
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/common/Makefile patched_uboot-sunxi-r16/common/Makefile
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/common/Makefile	2022-10-07 03:35:16.000000000 +0000
+++ patched_uboot-sunxi-r16/common/Makefile	2022-10-17 14:23:20.454017392 +0000
@@ -47,7 +47,8 @@
 COBJS-y += env_common.o
 COBJS-$(CONFIG_ENV_IS_IN_DATAFLASH) += env_dataflash.o
 COBJS-$(CONFIG_ENV_IS_IN_EEPROM) += env_eeprom.o
-XCOBJS-$(CONFIG_ENV_IS_EMBEDDED) += env_embedded.o
+# HACK: make it build for sunxi-memboot without having to specify u-boot.lds
+COBJS-$(CONFIG_ENV_IS_EMBEDDED) += env_embedded.o
 COBJS-$(CONFIG_ENV_IS_IN_EEPROM) += env_embedded.o
 XCOBJS-$(CONFIG_ENV_IS_IN_FLASH) += env_embedded.o
 COBJS-$(CONFIG_ENV_IS_IN_NVRAM) += env_embedded.o
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/drivers/mmc/sunxi_mmc.c patched_uboot-sunxi-r16/drivers/mmc/sunxi_mmc.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/drivers/mmc/sunxi_mmc.c	2022-10-07 03:35:16.000000000 +0000
+++ patched_uboot-sunxi-r16/drivers/mmc/sunxi_mmc.c	2022-10-17 14:31:45.888456036 +0000
@@ -256,7 +256,7 @@
 static int mmc_resource_init(int sdc_no)
 {
 	struct sunxi_mmc_host* mmchost = &mmc_host[sdc_no];
-	MMCDBG("init mmc %d resource\n", sdc_no);
+	MMCINFO("init mmc %d resource\n", sdc_no);
 	switch (sdc_no) {
 		case 0:
 			mmchost->reg = (struct sunxi_mmc *)SUNXI_MMC0_BASE;
@@ -372,333 +372,355 @@
 	int rval;
 	int ret = 0;
 	struct sunxi_mmc_host* mmchost = &mmc_host[sdc_no];
+    MMCINFO("get_fex_para - gathering info from script.bin...\n");
+	
+	switch(sdc_no){
+		
+		
+		case 0:
+		{
+			gpio_request_simple("card0_boot_para", NULL);
 
-	if(sdc_no == 0)
-	{
-		gpio_request_simple("card0_boot_para", NULL);
-
-		ret = script_parser_fetch("card0_boot_para","sdc_wipe", &rval, 1);
-		if(ret < 0)
-        	MMCINFO("get sdc_phy_wipe fail.\n");
-		else {
-			if (rval & DRV_PARA_DISABLE_SECURE_WIPE) {
-				MMCINFO("disable driver secure wipe operation.\n");
-				mmc_dev[sdc_no].drv_wipe_feature |= DRV_PARA_DISABLE_SECURE_WIPE;
-			} else if (rval & DRV_PARA_DISABLE_EMMC_SANITIZE) {
-				MMCINFO("disable emmc sanitize feature.\n");
-				mmc_dev[sdc_no].drv_wipe_feature |= DRV_PARA_DISABLE_EMMC_SANITIZE;
-			} else if (rval & DRV_PARA_DISABLE_EMMC_SECURE_PURGE) {
-				MMCINFO("disable emmc secure purge feature.\n");
-				mmc_dev[sdc_no].drv_wipe_feature |= DRV_PARA_DISABLE_EMMC_SECURE_PURGE;
-			} else if (rval & DRV_PARA_DISABLE_EMMC_TRIM) {
-				MMCINFO("disable emmc trim feature.\n");
-				mmc_dev[sdc_no].drv_wipe_feature |= DRV_PARA_DISABLE_EMMC_TRIM;
+			ret = script_parser_fetch("card0_boot_para","sdc_wipe", &rval, 1);
+			if(ret < 0)
+				MMCINFO("get sdc_phy_wipe fail.\n");
+			else {
+				if (rval & DRV_PARA_DISABLE_SECURE_WIPE) {
+					MMCINFO("disable driver secure wipe operation.\n");
+					mmc_dev[sdc_no].drv_wipe_feature |= DRV_PARA_DISABLE_SECURE_WIPE;
+				} else if (rval & DRV_PARA_DISABLE_EMMC_SANITIZE) {
+					MMCINFO("disable emmc sanitize feature.\n");
+					mmc_dev[sdc_no].drv_wipe_feature |= DRV_PARA_DISABLE_EMMC_SANITIZE;
+				} else if (rval & DRV_PARA_DISABLE_EMMC_SECURE_PURGE) {
+					MMCINFO("disable emmc secure purge feature.\n");
+					mmc_dev[sdc_no].drv_wipe_feature |= DRV_PARA_DISABLE_EMMC_SECURE_PURGE;
+				} else if (rval & DRV_PARA_DISABLE_EMMC_TRIM) {
+					MMCINFO("disable emmc trim feature.\n");
+					mmc_dev[sdc_no].drv_wipe_feature |= DRV_PARA_DISABLE_EMMC_TRIM;
+				}
 			}
-		}
 
-		ret = script_parser_fetch("card0_boot_para", "sdc_erase", &rval, 1);
-		if(ret < 0)
-			MMCINFO("get sdc0 sdc_erase fail.\n");
-		else {
-			if (rval & DRV_PARA_DISABLE_EMMC_ERASE) {
-				MMCINFO("disable emmc erase.\n");
-				mmc_dev[sdc_no].drv_erase_feature |= DRV_PARA_DISABLE_EMMC_ERASE;
-			} else if (rval & DRV_PARA_ENABLE_EMMC_SANITIZE_WHEN_ERASE) {
-				MMCINFO("enable emmc sanitize when erase.\n");
-				mmc_dev[sdc_no].drv_erase_feature |= DRV_PARA_ENABLE_EMMC_SANITIZE_WHEN_ERASE;
-			}
-		}
-
-		ret = script_parser_fetch("card0_boot_para","sdc_f_max", &rval, 1);
-		if(ret < 0)
-        MMCINFO("get sdc_f_max fail,use default %dHz\n",mmc_dev[sdc_no].f_max);
-		else{
-				if((rval>mmc_dev[sdc_no].f_max)||(rval<mmc_dev[sdc_no].f_min)){
-					MMCINFO("input sdc_f_max wrong ,use default sdc_f_max %d (min %d)\n",
-						mmc_dev[sdc_no].f_max, mmc_dev[sdc_no].f_min);
-				}else{
-					mmc_dev[sdc_no].f_max = rval;
-					MMCINFO("get sdc_f_max ok, sdc_f_max = %d\n", mmc_dev[sdc_no].f_max);
+			ret = script_parser_fetch("card0_boot_para", "sdc_erase", &rval, 1);
+			if(ret < 0)
+				MMCINFO("get sdc0 sdc_erase fail.\n");
+			else {
+				if (rval & DRV_PARA_DISABLE_EMMC_ERASE) {
+					MMCINFO("disable emmc erase.\n");
+					mmc_dev[sdc_no].drv_erase_feature |= DRV_PARA_DISABLE_EMMC_ERASE;
+				} else if (rval & DRV_PARA_ENABLE_EMMC_SANITIZE_WHEN_ERASE) {
+					MMCINFO("enable emmc sanitize when erase.\n");
+					mmc_dev[sdc_no].drv_erase_feature |= DRV_PARA_ENABLE_EMMC_SANITIZE_WHEN_ERASE;
 				}
-		}
+			}
 
+			ret = script_parser_fetch("card0_boot_para","sdc_f_max", &rval, 1);
+			if(ret < 0)
+			MMCINFO("get sdc_f_max fail,use default %dHz\n",mmc_dev[sdc_no].f_max);
+			else{
+					if((rval>mmc_dev[sdc_no].f_max)||(rval<mmc_dev[sdc_no].f_min)){
+						MMCINFO("input sdc_f_max wrong ,use default sdc_f_max %d (min %d)\n",
+							mmc_dev[sdc_no].f_max, mmc_dev[sdc_no].f_min);
+					}else{
+						mmc_dev[sdc_no].f_max = rval;
+						MMCINFO("get sdc_f_max ok, sdc_f_max = %d\n", mmc_dev[sdc_no].f_max);
+					}
+			}
 
-		ret = script_parser_fetch("card0_boot_para","sdc_ex_dly_used", &rval, 1);
-		if(ret < 0){
-        		MMCINFO("get sdc_ex_dly_used fail,use default dly\n");
-			return;
-		}else{
-				if(rval == 1){  //maual sample point from fex
-					MMCINFO("get sdc_ex_dly_used ok\n");
-					MMCINFO("use manual sample point  in fex\n");
-				}else{
-					MMCINFO("undefined value %d,use default dly\n",rval);
-					return;
-				}
-		}
-		/*************************25M dly*************************************/
-		ret = script_parser_fetch("card0_boot_para","sdc_odly_25M", &rval, 1);
-		if(ret < 0)
-        MMCINFO("get sdc_odly_25M fail,use default dly %d\n",mmchost->mmc_clk_dly[MMC_CLK_25M].oclk_dly);
-		else{
-				if((rval>7)||(rval<0)){
-					MMCINFO("input sdc_odly_25M wrong ,use default dly %d\n",mmchost->mmc_clk_dly[MMC_CLK_25M].oclk_dly);
-				}else{
-					mmchost->mmc_clk_dly[MMC_CLK_25M].oclk_dly = rval;
-					MMCINFO("get sdc_odly_25M ok, odly = %d\n", mmchost->mmc_clk_dly[MMC_CLK_25M].oclk_dly);
-				}
-		}
 
-		ret = script_parser_fetch("card0_boot_para","sdc_sdly_25M", &rval, 1);
-		if(ret < 0)
-        MMCINFO("get sdc_sdly_25M fail,use default dly %d\n",mmchost->mmc_clk_dly[MMC_CLK_25M].sclk_dly);
-		else{
-				if((rval>7)||(rval<0)){
-					MMCINFO("input sdc_sdly_25M wrong ,use default dly %d\n",mmchost->mmc_clk_dly[MMC_CLK_25M].sclk_dly);
-				}else{
-					mmchost->mmc_clk_dly[MMC_CLK_25M].sclk_dly = rval;
-					MMCINFO("get sdc_sdly_25M ok, sdly = %d\n", mmchost->mmc_clk_dly[MMC_CLK_25M].sclk_dly);
-				}
-		}
+			ret = script_parser_fetch("card0_boot_para","sdc_ex_dly_used", &rval, 1);
+			if(ret < 0){
+					MMCINFO("get sdc_ex_dly_used fail,use default dly\n");
+				return;
+			}else{
+					if(rval == 1){  //maual sample point from fex
+						MMCINFO("get sdc_ex_dly_used ok\n");
+						MMCINFO("use manual sample point  in fex\n");
+					}else{
+						MMCINFO("undefined value %d,use default dly\n",rval);
+						return;
+					}
+			}
+			/*************************25M dly*************************************/
+			ret = script_parser_fetch("card0_boot_para","sdc_odly_25M", &rval, 1);
+			if(ret < 0)
+			MMCINFO("get sdc_odly_25M fail,use default dly %d\n",mmchost->mmc_clk_dly[MMC_CLK_25M].oclk_dly);
+			else{
+					if((rval>7)||(rval<0)){
+						MMCINFO("input sdc_odly_25M wrong ,use default dly %d\n",mmchost->mmc_clk_dly[MMC_CLK_25M].oclk_dly);
+					}else{
+						mmchost->mmc_clk_dly[MMC_CLK_25M].oclk_dly = rval;
+						MMCINFO("get sdc_odly_25M ok, odly = %d\n", mmchost->mmc_clk_dly[MMC_CLK_25M].oclk_dly);
+					}
+			}
 
-			/*************************50M dly*************************************/
-		ret = script_parser_fetch("card0_boot_para","sdc_odly_50M", &rval, 1);
-		if(ret < 0)
-        MMCINFO("get sdc_odly_50M fail,use default dly %d\n",mmchost->mmc_clk_dly[MMC_CLK_50M].oclk_dly);
-		else{
-			  if((rval>7)||(rval<0)){
-			  	MMCINFO("input sdc_odly_50M wrong, use default dly %d\n", mmchost->mmc_clk_dly[MMC_CLK_50M].oclk_dly);
-			  }else{
-					mmchost->mmc_clk_dly[MMC_CLK_50M].oclk_dly = rval;
-					MMCINFO("get sdc_odly_50M ok, odly = %d\n", mmchost->mmc_clk_dly[MMC_CLK_50M].oclk_dly);
-				}
-		}
+			ret = script_parser_fetch("card0_boot_para","sdc_sdly_25M", &rval, 1);
+			if(ret < 0)
+			MMCINFO("get sdc_sdly_25M fail,use default dly %d\n",mmchost->mmc_clk_dly[MMC_CLK_25M].sclk_dly);
+			else{
+					if((rval>7)||(rval<0)){
+						MMCINFO("input sdc_sdly_25M wrong ,use default dly %d\n",mmchost->mmc_clk_dly[MMC_CLK_25M].sclk_dly);
+					}else{
+						mmchost->mmc_clk_dly[MMC_CLK_25M].sclk_dly = rval;
+						MMCINFO("get sdc_sdly_25M ok, sdly = %d\n", mmchost->mmc_clk_dly[MMC_CLK_25M].sclk_dly);
+					}
+			}
 
-		ret = script_parser_fetch("card0_boot_para","sdc_sdly_50M", &rval, 1);
-		if(ret < 0)
-        MMCINFO("get sdc_sdly_50M fail,use default dly %d\n",mmchost->mmc_clk_dly[MMC_CLK_50M].sclk_dly);
-		else{
-				if((rval>7)||(rval<0)){
-					MMCINFO("input sdc_sdly_50M wrong, use default dly %d\n", mmchost->mmc_clk_dly[MMC_CLK_50M].sclk_dly);
-				}else{
-					mmchost->mmc_clk_dly[MMC_CLK_50M].sclk_dly = rval;
-					MMCINFO("get sdc_sdly_50M ok, sdly = %d\n", mmchost->mmc_clk_dly[MMC_CLK_50M].sclk_dly);
-				}
-		}
+				/*************************50M dly*************************************/
+			ret = script_parser_fetch("card0_boot_para","sdc_odly_50M", &rval, 1);
+			if(ret < 0)
+			MMCINFO("get sdc_odly_50M fail,use default dly %d\n",mmchost->mmc_clk_dly[MMC_CLK_50M].oclk_dly);
+			else{
+				  if((rval>7)||(rval<0)){
+					MMCINFO("input sdc_odly_50M wrong, use default dly %d\n", mmchost->mmc_clk_dly[MMC_CLK_50M].oclk_dly);
+				  }else{
+						mmchost->mmc_clk_dly[MMC_CLK_50M].oclk_dly = rval;
+						MMCINFO("get sdc_odly_50M ok, odly = %d\n", mmchost->mmc_clk_dly[MMC_CLK_50M].oclk_dly);
+					}
+			}
 
+			ret = script_parser_fetch("card0_boot_para","sdc_sdly_50M", &rval, 1);
+			if(ret < 0)
+			MMCINFO("get sdc_sdly_50M fail,use default dly %d\n",mmchost->mmc_clk_dly[MMC_CLK_50M].sclk_dly);
+			else{
+					if((rval>7)||(rval<0)){
+						MMCINFO("input sdc_sdly_50M wrong, use default dly %d\n", mmchost->mmc_clk_dly[MMC_CLK_50M].sclk_dly);
+					}else{
+						mmchost->mmc_clk_dly[MMC_CLK_50M].sclk_dly = rval;
+						MMCINFO("get sdc_sdly_50M ok, sdly = %d\n", mmchost->mmc_clk_dly[MMC_CLK_50M].sclk_dly);
+					}
+			}
 
 
-	}else {// if(sdc_no == 2)
-		gpio_request_simple("card2_boot_para", NULL);
+         break;
+		}
 
-		ret = script_parser_fetch("card2_boot_para","sdc_wipe", &rval, 1);
-		if(ret < 0)
-        	MMCINFO("get sdc_phy_wipe fail.\n");
-		else {
-			if (rval & DRV_PARA_DISABLE_SECURE_WIPE) {
-				MMCINFO("disable driver secure wipe operation.\n");
-				mmc_dev[sdc_no].drv_wipe_feature |= DRV_PARA_DISABLE_SECURE_WIPE;
-			} else if (rval & DRV_PARA_DISABLE_EMMC_SANITIZE) {
-				MMCINFO("disable emmc sanitize feature.\n");
-				mmc_dev[sdc_no].drv_wipe_feature |= DRV_PARA_DISABLE_EMMC_SANITIZE;
-			} else if (rval & DRV_PARA_DISABLE_EMMC_SECURE_PURGE) {
-				MMCINFO("disable emmc secure purge feature.\n");
-				mmc_dev[sdc_no].drv_wipe_feature |= DRV_PARA_DISABLE_EMMC_SECURE_PURGE;
-			} else if (rval & DRV_PARA_DISABLE_EMMC_TRIM) {
-				MMCINFO("disable emmc trim feature.\n");
-				mmc_dev[sdc_no].drv_wipe_feature |= DRV_PARA_DISABLE_EMMC_TRIM;
+        case 2:		
+		{// if(sdc_no == 2)
+			gpio_request_simple("card2_boot_para", NULL);
+
+			ret = script_parser_fetch("card2_boot_para","sdc_wipe", &rval, 1);
+			if(ret < 0)
+				MMCINFO("get sdc_phy_wipe fail.\n");
+			else {
+				if (rval & DRV_PARA_DISABLE_SECURE_WIPE) {
+					MMCINFO("disable driver secure wipe operation.\n");
+					mmc_dev[sdc_no].drv_wipe_feature |= DRV_PARA_DISABLE_SECURE_WIPE;
+				} else if (rval & DRV_PARA_DISABLE_EMMC_SANITIZE) {
+					MMCINFO("disable emmc sanitize feature.\n");
+					mmc_dev[sdc_no].drv_wipe_feature |= DRV_PARA_DISABLE_EMMC_SANITIZE;
+				} else if (rval & DRV_PARA_DISABLE_EMMC_SECURE_PURGE) {
+					MMCINFO("disable emmc secure purge feature.\n");
+					mmc_dev[sdc_no].drv_wipe_feature |= DRV_PARA_DISABLE_EMMC_SECURE_PURGE;
+				} else if (rval & DRV_PARA_DISABLE_EMMC_TRIM) {
+					MMCINFO("disable emmc trim feature.\n");
+					mmc_dev[sdc_no].drv_wipe_feature |= DRV_PARA_DISABLE_EMMC_TRIM;
+				}
 			}
-		}
 
-		ret = script_parser_fetch("card2_boot_para", "sdc_erase", &rval, 1);
-		if(ret < 0)
-			MMCINFO("get sdc0 sdc_erase fail.\n");
-		else {
-			if (rval & DRV_PARA_DISABLE_EMMC_ERASE) {
-				MMCINFO("disable emmc erase.\n");
-				mmc_dev[sdc_no].drv_erase_feature |= DRV_PARA_DISABLE_EMMC_ERASE;
-			} else if (rval & DRV_PARA_ENABLE_EMMC_SANITIZE_WHEN_ERASE) {
-				MMCINFO("enable emmc sanitize.\n");
-				mmc_dev[sdc_no].drv_erase_feature |= DRV_PARA_ENABLE_EMMC_SANITIZE_WHEN_ERASE;
+			ret = script_parser_fetch("card2_boot_para", "sdc_erase", &rval, 1);
+			if(ret < 0)
+				MMCINFO("get sdc0 sdc_erase fail.\n");
+			else {
+				if (rval & DRV_PARA_DISABLE_EMMC_ERASE) {
+					MMCINFO("disable emmc erase.\n");
+					mmc_dev[sdc_no].drv_erase_feature |= DRV_PARA_DISABLE_EMMC_ERASE;
+				} else if (rval & DRV_PARA_ENABLE_EMMC_SANITIZE_WHEN_ERASE) {
+					MMCINFO("enable emmc sanitize.\n");
+					mmc_dev[sdc_no].drv_erase_feature |= DRV_PARA_ENABLE_EMMC_SANITIZE_WHEN_ERASE;
+				}
 			}
-		}
 
-#if defined(CONFIG_ARCH_SUN8IW5P1) || defined(CONFIG_ARCH_SUN8IW6P1) || defined(CONFIG_ARCH_SUN8IW8P1)||(defined CONFIG_ARCH_SUN8IW7P1)|| (defined CONFIG_ARCH_SUN8IW9P1)
-		/*************************sdc_2xmode*************************************/
-		ret = script_parser_fetch("card2_boot_para","sdc_2xmode", &rval, 1);
-		if(ret < 0)
-		{
-			mmc_dev[sdc_no].host_func = MMC_NO_FUNC;
-			MMCINFO("get sdc_2xmode fail  used =  %d\n",mmc_dev[sdc_no].host_func);
-		}
-		else
-		{
-			if(rval == 1)
+	#if defined(CONFIG_ARCH_SUN8IW5P1) || defined(CONFIG_ARCH_SUN8IW6P1) || defined(CONFIG_ARCH_SUN8IW8P1)||(defined CONFIG_ARCH_SUN8IW7P1)|| (defined CONFIG_ARCH_SUN8IW9P1)
+			/*************************sdc_2xmode*************************************/
+			ret = script_parser_fetch("card2_boot_para","sdc_2xmode", &rval, 1);
+			if(ret < 0)
 			{
-				mmc_dev[sdc_no].host_func = MMC_HOST_2XMODE_FUNC;
+				mmc_dev[sdc_no].host_func = MMC_NO_FUNC;
+				MMCINFO("get sdc_2xmode fail  used =  %d\n",mmc_dev[sdc_no].host_func);
 			}
 			else
 			{
-				mmc_dev[sdc_no].host_func = MMC_NO_FUNC;
+				if(rval == 1)
+				{
+					mmc_dev[sdc_no].host_func = MMC_HOST_2XMODE_FUNC;
+				}
+				else
+				{
+					mmc_dev[sdc_no].host_func = MMC_NO_FUNC;
+				}
+				MMCINFO("get sdc_2xmode ok, val = %d\n", mmc_dev[sdc_no].host_func);
 			}
-			MMCINFO("get sdc_2xmode ok, val = %d\n", mmc_dev[sdc_no].host_func);
-		}
-		/*************************sdc_ddrmode*************************************/
-		ret = script_parser_fetch("card2_boot_para","sdc_ddrmode", &rval, 1);
-		if(ret < 0)
-		{
-			mmc_dev[sdc_no].mmc_func_en.ddr_func_en = 0;
-			MMCINFO("get sdc_ddrmode fail  used =  %d\n",mmc_dev[sdc_no].mmc_func_en.ddr_func_en );
-		}
-		else
-		{
-			if(rval == 1)
+			/*************************sdc_ddrmode*************************************/
+			ret = script_parser_fetch("card2_boot_para","sdc_ddrmode", &rval, 1);
+			if(ret < 0)
 			{
-				mmc_dev[sdc_no].mmc_func_en.ddr_func_en = 1;
+				mmc_dev[sdc_no].mmc_func_en.ddr_func_en = 0;
+				MMCINFO("get sdc_ddrmode fail  used =  %d\n",mmc_dev[sdc_no].mmc_func_en.ddr_func_en );
 			}
 			else
 			{
-				mmc_dev[sdc_no].mmc_func_en.ddr_func_en = 0;
-			}
-			MMCINFO("get sdc_ddrmode ok, val = %d\n", mmc_dev[sdc_no].mmc_func_en.ddr_func_en );
-		}
-#endif
-		ret = script_parser_fetch("card2_boot_para","sdc_f_max", &rval, 1);
-		if(ret < 0)
-            MMCINFO("get sdc_f_max fail,use default  %dHz\n", mmc_dev[sdc_no].f_max);
-		else {
-				if((rval>mmc_dev[sdc_no].f_max)||(rval<mmc_dev[sdc_no].f_min)){
-					MMCINFO("input sdc_f_max wrong %d,use default sdc_f_max %d (min %d)\n",
-						rval, mmc_dev[sdc_no].f_max, mmc_dev[sdc_no].f_min);
-				}else{
-					mmc_dev[sdc_no].f_max = rval;
-					MMCINFO("get sdc_f_max ok, sdc_f_max = %d\n", mmc_dev[sdc_no].f_max);
+				if(rval == 1)
+				{
+					mmc_dev[sdc_no].mmc_func_en.ddr_func_en = 1;
 				}
-		}
+				else
+				{
+					mmc_dev[sdc_no].mmc_func_en.ddr_func_en = 0;
+				}
+				MMCINFO("get sdc_ddrmode ok, val = %d\n", mmc_dev[sdc_no].mmc_func_en.ddr_func_en );
+			}
+	#endif
+			ret = script_parser_fetch("card2_boot_para","sdc_f_max", &rval, 1);
+			if(ret < 0)
+				MMCINFO("get sdc_f_max fail,use default  %dHz\n", mmc_dev[sdc_no].f_max);
+			else {
+					if((rval>mmc_dev[sdc_no].f_max)||(rval<mmc_dev[sdc_no].f_min)){
+						MMCINFO("input sdc_f_max wrong %d,use default sdc_f_max %d (min %d)\n",
+							rval, mmc_dev[sdc_no].f_max, mmc_dev[sdc_no].f_min);
+					}else{
+						mmc_dev[sdc_no].f_max = rval;
+						MMCINFO("get sdc_f_max ok, sdc_f_max = %d\n", mmc_dev[sdc_no].f_max);
+					}
+			}
 
-		ret = script_parser_fetch("card2_boot_para","card_line", &rval, 1);
-		if(ret < 0)
-        MMCINFO("get card_line fail,use default card_line %d\n",4);
-		else{
-#ifndef CONFIG_ARCH_SUN7I
-				if((rval!=8)&&(rval!=1)&&(rval!=4)){
-					MMCINFO("input card_line wrong ,use default card_line %d\n",4);
-				}else{
-					if(rval == 8 ){
-						mmc_dev[sdc_no].host_caps |= MMC_MODE_8BIT;
-					}else if(rval == 4){
-						mmc_dev[sdc_no].host_caps &= ~MMC_MODE_8BIT;
-						mmc_dev[sdc_no].host_caps |= MMC_MODE_4BIT;
+			ret = script_parser_fetch("card2_boot_para","card_line", &rval, 1);
+			if(ret < 0)
+			MMCINFO("get card_line fail,use default card_line %d\n",4);
+			else{
+	#ifndef CONFIG_ARCH_SUN7I
+					if((rval!=8)&&(rval!=1)&&(rval!=4)){
+						MMCINFO("input card_line wrong ,use default card_line %d\n",4);
 					}else{
-						mmc_dev[sdc_no].host_caps &= ~MMC_MODE_8BIT;
-						mmc_dev[sdc_no].host_caps &= ~MMC_MODE_4BIT;
+						if(rval == 8 ){
+							mmc_dev[sdc_no].host_caps |= MMC_MODE_8BIT;
+						}else if(rval == 4){
+							mmc_dev[sdc_no].host_caps &= ~MMC_MODE_8BIT;
+							mmc_dev[sdc_no].host_caps |= MMC_MODE_4BIT;
+						}else{
+							mmc_dev[sdc_no].host_caps &= ~MMC_MODE_8BIT;
+							mmc_dev[sdc_no].host_caps &= ~MMC_MODE_4BIT;
+						}
+						MMCINFO("get card_line ok, card_line = %d\n", rval);
 					}
-					MMCINFO("get card_line ok, card_line = %d\n", rval);
-				}
-#else
-				if((rval!=1)&&(rval!=4)){
-					MMCINFO("input card_line wrong ,use default card_line %d\n",4);
-				}else{
-					if(rval == 4){
-						mmc_dev[sdc_no].host_caps &= ~MMC_MODE_8BIT;
-						mmc_dev[sdc_no].host_caps |= MMC_MODE_4BIT;
+	#else
+					if((rval!=1)&&(rval!=4)){
+						MMCINFO("input card_line wrong ,use default card_line %d\n",4);
 					}else{
-						mmc_dev[sdc_no].host_caps &= ~MMC_MODE_8BIT;
-						mmc_dev[sdc_no].host_caps &= ~MMC_MODE_4BIT;
+						if(rval == 4){
+							mmc_dev[sdc_no].host_caps &= ~MMC_MODE_8BIT;
+							mmc_dev[sdc_no].host_caps |= MMC_MODE_4BIT;
+						}else{
+							mmc_dev[sdc_no].host_caps &= ~MMC_MODE_8BIT;
+							mmc_dev[sdc_no].host_caps &= ~MMC_MODE_4BIT;
+						}
+						MMCINFO("get card_line ok, card_line = %d\n", rval);
 					}
-					MMCINFO("get card_line ok, card_line = %d\n", rval);
-				}
-#endif
-		}
+	#endif
+			}
 
 
-		ret = script_parser_fetch("card2_boot_para","sdc_ex_dly_used", &rval, 1);
-		if(ret < 0){
-        		MMCINFO("get sdc_ex_dly_used fail,use default\n");
-			return;
-		}else{
-				int rval_ker =0;
-				ret = script_parser_fetch("mmc2_para","sdc_ex_dly_used", &rval_ker, 1);
-				int work_mode = uboot_spare_head.boot_data.work_mode;
-				//MMCINFO("ret%d,rval_ker%d,rval%d",ret,rval_ker,rval);
-				if((ret>=0)&&(rval_ker == 2)&&(rval == 2)){//only when kernal use auto sample,uboot will use auto sample.
-					struct tuning_sdly  *sdly= (struct tuning_sdly  *)uboot_spare_head.boot_data.sdcard_spare_data;
-					mmc_dev[sdc_no].sample_mode = AUTO_SAMPLE_MODE;
-					MMCINFO("get sdc_ex_dly_used ok\n");
-					MMCINFO("use auto sdly \n");
-					if(work_mode != WORK_MODE_BOOT){
-						//usb product will auto get sample point,so no need to get auto sdly,so first used default value
-						MMCINFO("Product will auto sample,not need to get auto sdly\n");
+			ret = script_parser_fetch("card2_boot_para","sdc_ex_dly_used", &rval, 1);
+			if(ret < 0){
+					MMCINFO("get sdc_ex_dly_used fail,use default\n");
+				return;
+			}else{
+					int rval_ker =0;
+					ret = script_parser_fetch("mmc2_para","sdc_ex_dly_used", &rval_ker, 1);
+					int work_mode = uboot_spare_head.boot_data.work_mode;
+					//MMCINFO("ret%d,rval_ker%d,rval%d",ret,rval_ker,rval);
+					if((ret>=0)&&(rval_ker == 2)&&(rval == 2)){//only when kernal use auto sample,uboot will use auto sample.
+						struct tuning_sdly  *sdly= (struct tuning_sdly  *)uboot_spare_head.boot_data.sdcard_spare_data;
+						mmc_dev[sdc_no].sample_mode = AUTO_SAMPLE_MODE;
+						MMCINFO("get sdc_ex_dly_used ok\n");
+						MMCINFO("use auto sdly \n");
+						if(work_mode != WORK_MODE_BOOT){
+							//usb product will auto get sample point,so no need to get auto sdly,so first used default value
+							MMCINFO("Product will auto sample,not need to get auto sdly\n");
+							return;
+						}
+						MMCDBG("get auto sdly %d in 25M\n",sdly->sdly_25M);
+						mmchost->mmc_clk_dly[MMC_CLK_25M].sclk_dly = sdly->sdly_25M;
+						MMCDBG("get auto sdly %d in 50M\n",sdly->sdly_50M);
+						mmchost->mmc_clk_dly[MMC_CLK_50M].sclk_dly = sdly->sdly_50M;
+						MMCINFO("auto sdly %d in 25M \n", mmchost->mmc_clk_dly[MMC_CLK_25M].sclk_dly);
+						MMCINFO("auto sdly %d in 50M \n", mmchost->mmc_clk_dly[MMC_CLK_50M].sclk_dly);
+						return;
+					}else if(rval == 1){  //maual sample point from fex
+						MMCINFO("get sdc_ex_dly_used ok\n");
+						MMCINFO("use manual sample point  in fex\n");
+					}else{
+						MMCINFO("undefined value %d or kernel not use auto sample,use default dly\n",rval);
 						return;
 					}
-					MMCDBG("get auto sdly %d in 25M\n",sdly->sdly_25M);
-					mmchost->mmc_clk_dly[MMC_CLK_25M].sclk_dly = sdly->sdly_25M;
-					MMCDBG("get auto sdly %d in 50M\n",sdly->sdly_50M);
-					mmchost->mmc_clk_dly[MMC_CLK_50M].sclk_dly = sdly->sdly_50M;
-					MMCINFO("auto sdly %d in 25M \n", mmchost->mmc_clk_dly[MMC_CLK_25M].sclk_dly);
-					MMCINFO("auto sdly %d in 50M \n", mmchost->mmc_clk_dly[MMC_CLK_50M].sclk_dly);
-					return;
-				}else if(rval == 1){  //maual sample point from fex
-					MMCINFO("get sdc_ex_dly_used ok\n");
-					MMCINFO("use manual sample point  in fex\n");
-				}else{
-					MMCINFO("undefined value %d or kernel not use auto sample,use default dly\n",rval);
-					return;
-				}
-		}
-
+			}
 
-		/*************************25M dly*************************************/
-		ret = script_parser_fetch("card2_boot_para","sdc_odly_25M", &rval, 1);
-		if(ret < 0){
-        		MMCINFO("get sdc_odly_25M fail,use default dly %d\n",mmchost->mmc_clk_dly[MMC_CLK_25M].oclk_dly);
-		}else{
-				if((rval>7)||(rval<0)){
-					MMCINFO("input sdc_odly_25M wrong ,use default dly %d\n",mmchost->mmc_clk_dly[MMC_CLK_25M].oclk_dly);
-				}else{
-					mmchost->mmc_clk_dly[MMC_CLK_25M].oclk_dly = rval;
-					MMCINFO("get sdc_odly_25M ok, odly = %d\n", mmchost->mmc_clk_dly[MMC_CLK_25M].oclk_dly);
-				}
-		}
 
-		ret = script_parser_fetch("card2_boot_para","sdc_sdly_25M", &rval, 1);
-		if(ret < 0)
-        MMCINFO("get sdc_sdly_25M fail,use default dly %d\n",mmchost->mmc_clk_dly[MMC_CLK_25M].sclk_dly);
-		else{
-				if((rval>7)||(rval<0)){
-					MMCINFO("input sdc_sdly_25M wrong ,use default dly %d\n",mmchost->mmc_clk_dly[MMC_CLK_25M].sclk_dly);
-				}else{
-					mmchost->mmc_clk_dly[MMC_CLK_25M].sclk_dly = rval;
-					MMCINFO("get sdc_sdly_25M ok, sdly = %d\n", mmchost->mmc_clk_dly[MMC_CLK_25M].sclk_dly);
-				}
-		}
+			/*************************25M dly*************************************/
+			ret = script_parser_fetch("card2_boot_para","sdc_odly_25M", &rval, 1);
+			if(ret < 0){
+					MMCINFO("get sdc_odly_25M fail,use default dly %d\n",mmchost->mmc_clk_dly[MMC_CLK_25M].oclk_dly);
+			}else{
+					if((rval>7)||(rval<0)){
+						MMCINFO("input sdc_odly_25M wrong ,use default dly %d\n",mmchost->mmc_clk_dly[MMC_CLK_25M].oclk_dly);
+					}else{
+						mmchost->mmc_clk_dly[MMC_CLK_25M].oclk_dly = rval;
+						MMCINFO("get sdc_odly_25M ok, odly = %d\n", mmchost->mmc_clk_dly[MMC_CLK_25M].oclk_dly);
+					}
+			}
 
-			/*************************50M dly*************************************/
-		ret = script_parser_fetch("card2_boot_para","sdc_odly_50M", &rval, 1);
-		if(ret < 0)
-        MMCINFO("get sdc_odly_50M fail,use default dly %d\n",mmchost->mmc_clk_dly[MMC_CLK_50M].oclk_dly);
-		else{
-			  if((rval>7)||(rval<0)){
-			  	MMCINFO("input sdc_odly_50M wrong, use default dly %d\n", mmchost->mmc_clk_dly[MMC_CLK_50M].oclk_dly);
-			  }else{
-					mmchost->mmc_clk_dly[MMC_CLK_50M].oclk_dly = rval;
-					MMCINFO("get sdc_odly_50M ok, odly = %d\n", mmchost->mmc_clk_dly[MMC_CLK_50M].oclk_dly);
-				}
-		}
+			ret = script_parser_fetch("card2_boot_para","sdc_sdly_25M", &rval, 1);
+			if(ret < 0)
+			MMCINFO("get sdc_sdly_25M fail,use default dly %d\n",mmchost->mmc_clk_dly[MMC_CLK_25M].sclk_dly);
+			else{
+					if((rval>7)||(rval<0)){
+						MMCINFO("input sdc_sdly_25M wrong ,use default dly %d\n",mmchost->mmc_clk_dly[MMC_CLK_25M].sclk_dly);
+					}else{
+						mmchost->mmc_clk_dly[MMC_CLK_25M].sclk_dly = rval;
+						MMCINFO("get sdc_sdly_25M ok, sdly = %d\n", mmchost->mmc_clk_dly[MMC_CLK_25M].sclk_dly);
+					}
+			}
 
-		ret = script_parser_fetch("card2_boot_para","sdc_sdly_50M", &rval, 1);
-		if(ret < 0)
-        MMCINFO("get sdc_sdly_50M fail,use default dly %d\n",mmchost->mmc_clk_dly[MMC_CLK_50M].sclk_dly);
-		else{
-				if((rval>7)||(rval<0)){
-					MMCINFO("input sdc_sdly_50M wrong, use default dly %d\n", mmchost->mmc_clk_dly[MMC_CLK_50M].sclk_dly);
-				}else{
-					mmchost->mmc_clk_dly[MMC_CLK_50M].sclk_dly = rval;
-					MMCINFO("get sdc_sdly_50M ok, sdly = %d\n", mmchost->mmc_clk_dly[MMC_CLK_50M].sclk_dly);
-				}
-		}
+				/*************************50M dly*************************************/
+			ret = script_parser_fetch("card2_boot_para","sdc_odly_50M", &rval, 1);
+			if(ret < 0)
+			MMCINFO("get sdc_odly_50M fail,use default dly %d\n",mmchost->mmc_clk_dly[MMC_CLK_50M].oclk_dly);
+			else{
+				  if((rval>7)||(rval<0)){
+					MMCINFO("input sdc_odly_50M wrong, use default dly %d\n", mmchost->mmc_clk_dly[MMC_CLK_50M].oclk_dly);
+				  }else{
+						mmchost->mmc_clk_dly[MMC_CLK_50M].oclk_dly = rval;
+						MMCINFO("get sdc_odly_50M ok, odly = %d\n", mmchost->mmc_clk_dly[MMC_CLK_50M].oclk_dly);
+					}
+			}
 
+			ret = script_parser_fetch("card2_boot_para","sdc_sdly_50M", &rval, 1);
+			if(ret < 0)
+			MMCINFO("get sdc_sdly_50M fail,use default dly %d\n",mmchost->mmc_clk_dly[MMC_CLK_50M].sclk_dly);
+			else{
+					if((rval>7)||(rval<0)){
+						MMCINFO("input sdc_sdly_50M wrong, use default dly %d\n", mmchost->mmc_clk_dly[MMC_CLK_50M].sclk_dly);
+					}else{
+						mmchost->mmc_clk_dly[MMC_CLK_50M].sclk_dly = rval;
+						MMCINFO("get sdc_sdly_50M ok, sdly = %d\n", mmchost->mmc_clk_dly[MMC_CLK_50M].sclk_dly);
+					}
+			}
 
+        break;
+		}
+		
+		case 1:{
+		MMCINFO("get info for card 1...\n");
+		
+		gpio_request_simple("mmc1_para", NULL);
+		
+		MMCINFO("using defaults...\n");
+		
+		break;
+		}
+		default:
+			MMCINFO("Wrong mmc number %d\n", sdc_no);
+			break;
+	
 	}
 }
 
@@ -1890,6 +1912,9 @@
 	mmc->host_caps = MMC_MODE_4BIT | MMC_MODE_8BIT;
 	mmc->host_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS| MMC_MODE_HC | MMC_MODE_DDR_52MHz;
 
+
+MMCINFO("setting mmc->f_min and mmc->f_max...\n");
+
 	if(sdc_no == 0){
        mmc->f_min = 400000;
 #if defined(CONFIG_ARCH_SUN9IW1P1)
@@ -1904,9 +1929,16 @@
 #else
        mmc->f_max = 50000000;
 #endif
+	}else if (sdc_no == 1){
+       mmc->f_min = 400000;
+#if defined(CONFIG_ARCH_SUN9IW1P1)
+       mmc->f_max = 48000000;
+#else
+       mmc->f_max = 50000000;
+#endif
 	}
 
-	MMCDBG("mmc->host_caps %x\n",mmc->host_caps);
+	MMCINFO("mmc->host_caps %x\n",mmc->host_caps);
 	mmc_host[sdc_no].pdes = malloc(64 * 1024);
 	if(mmc_host[sdc_no].pdes == NULL){
 		MMCINFO("get mem for descriptor failed\n");
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/drivers/storage_type/sunxi_flash.c patched_uboot-sunxi-r16/drivers/storage_type/sunxi_flash.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/drivers/storage_type/sunxi_flash.c	2022-10-07 03:35:16.000000000 +0000
+++ patched_uboot-sunxi-r16/drivers/storage_type/sunxi_flash.c	2022-10-17 14:25:43.729579949 +0000
@@ -634,6 +634,7 @@
 			script_parser_patch("mmc0_para",  "sdc_detmode", &sdc_detmode, 1);
 			//script_parser_patch("mmc2_para",  "sdc_used",   &sdc2_used, 1);
 		}
+                
 		card_no = (storage_type == 1)?0:2;
 		printf("MMC:	 %d\n", card_no);
 		board_mmc_set_num(card_no);
@@ -664,12 +665,36 @@
 	}
 	else
 	{
+                //puts("Trying to set up sd at mmc1 even though we are using nand...\n");
+                tick_printf("Trying to set up sd at mmc1 even though we are using nand...\n");
+
+                card_no = 1;
+                printf("MMC:     %d\n", card_no);
+                board_mmc_set_num(card_no);
+                debug("set card number\n");
+                board_mmc_pre_init(card_no);
+                debug("begin to find mmc\n");
+                mmc_boot = find_mmc_device(card_no);
+                if(!mmc_boot){
+                        printf("fail to find one useful mmc card\n");
+                        //return -1;
+                }
+                debug("try to init mmc\n");
+                if (mmc_init(mmc_boot)) {
+                        puts("MMC init failed\n");
+                        //return  -1;
+                }
+                debug("mmc %d init ok\n", card_no);
+
+
+
+
 		nand_used = 1;
 		sdc2_used  = 0;
-		script_parser_patch("nand0_para", "nand0_used", &nand_used, 1);
-		script_parser_patch("nand1_para", "nand1_used", &nand_used, 1);
-		script_parser_patch("mmc2_para",  "sdc_used",   &sdc2_used, 1);
-		script_parser_patch("spi0",  "spi_used", &spi_used, 1);
+		//script_parser_patch("nand0_para", "nand0_used", &nand_used, 1);
+		//script_parser_patch("nand1_para", "nand1_used", &nand_used, 1);
+		//script_parser_patch("mmc2_para",  "sdc_used",   &sdc2_used, 1);
+		//script_parser_patch("spi0",  "spi_used", &spi_used, 1);
 
 		tick_printf("NAND: ");
 		if (workmode == WORK_MODE_BOOT) {
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/include/configs/sun8iw5p1.h patched_uboot-sunxi-r16/include/configs/sun8iw5p1.h
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/include/configs/sun8iw5p1.h	2022-10-07 03:35:16.000000000 +0000
+++ patched_uboot-sunxi-r16/include/configs/sun8iw5p1.h	2022-10-18 20:31:17.216244587 +0000
@@ -186,6 +186,7 @@
 #define CONFIG_CMD_MEMORY
 #define CONFIG_SUNXI_DISPLAY
 #define CONFIG_CMD_SUNXI_AUTO_FEL
+#define CONFIG_CMD_SOURCE
 
 #define CONFIG_SUNXI_AXP
 #define CONFIG_SUNXI_AXP22
@@ -314,6 +315,13 @@
 #define CONFIG_SUNXI_ENV_PARTITION		"env"	/* the partition name */
 
 /*------------------------------------------------------------------------
+ * Force embedded env
+ */
+#define CONFIG_ENV_IS_EMBEDDED
+// Override for a large blank space so it can be patched in
+#define CONFIG_ENV_EMBEDDED_BLANK 
+
+/*------------------------------------------------------------------------
  * we save the environment in a nand partition, the partition name is defined
  * in sysconfig.fex, which must be the same as CONFIG_SUNXI_NAND_ENV_PARTITION
  * if not, below CONFIG_ENV_ADDR and CONFIG_ENV_SIZE will be where to store env.
@@ -323,20 +331,25 @@
 #define CONFIG_CMD_SAVEENV
 
 #define CONFIG_EXTRA_ENV_SETTINGS \
-	"bootdelay=3\0" \
-	"bootcmd=run setargs_nand boot_normal\0" \
-	"console=ttyS0,115200\0" \
-	"nand_root=/dev/nandd\0" \
-	"mmc_root=/dev/mmcblk0p7\0" \
-	"init=/init\0" \
-	"loglevel=8\0" \
-	"setargs_nand=setenv bootargs console=${console} root=${nand_root}" \
-	"init=${init} loglevel=${loglevel} partitions=${partitions}\0" \
-	"setargs_mmc=setenv bootargs console=${console} root=${mmc_root}" \
-	"init=${init} loglevel=${loglevel} partitions=${partitions}\0" \
-	"boot_normal=sunxi_flash read 40007800 boot;boota 40007800\0" \
-	"boot_recovery=sunxi_flash read 40007800 recovery;boota 40007800\0" \
-	"boot_fastboot=fastboot\0"
+        "boot_fastboot=fastboot\0" \
+        "boot_normal=fatload sunxi_flash 2 43800000 uImage;bootm 43800000\0" \
+        "boot_recovery=fatload sunxi_flash 5 43800000 uImage; bootm 43800000\0" \
+        "bootcmd=if mmc rescan && fatload mmc 1 0x42000000 boot.scr; then source 0x42000000; else run bootcmdnormal; fi\0" \
+        "bootcmdnormal=run setargs_nand boot_normal\0" \
+        "bootdelay=0\0" \
+        "console=ttyS0,115200\0" \
+        "ethact=usb_ether\0" \
+        "filesize=240036\0" \
+        "init=/sbin/init\0" \
+        "loadaddr=0x42000000\0" \
+        "loglevel=0\0" \
+        "mmc_root=/dev/mmcblk0p2\0" \
+        "nand_root=/dev/nandd\0" \
+        "nor_root=/dev/mtdblock4\0" \
+        "partitions=boot-res@nanda:env@nandb:boot@nandc:rootfs@nandd:savedata@nande:recovery@nandf:misc@nandg:UDISK@nandh\0" \
+        "setargs_mmc=setenv bootargs console=${console} noinitrd root=${mmc_root} rootfstype=ext4 rootwait init=${init} ion_cma_512m=64m ion_cma_1g=176m ion_carveout_512m=96m ion_carveout_1g=150m coherent_pool=4m loglevel=${loglevel} partitions=${partitions}\0" \
+        "setargs_nand=setenv bootargs console=${console} noinitrd root=${nand_root} rootfstype=ext4 rootwait init=${init} ion_cma_512m=64m ion_cma_1g=176m ion_carveout_512m=96m ion_carveout_1g=150m coherent_pool=4m loglevel=${loglevel} partitions=${partitions}\0" \
+        "setargs_nor=setenv bootargs console=${console} noinitrd root=${nor_root} rootfstype=ext4 rootwait init=${init} ion_cma_512m=8m ion_cma_1g=176m ion_carveout_512m=8m ion_carveout_1g=150m coherent_pool=4m loglevel=${loglevel} partitions=${partitions}\0"
 
 #define CONFIG_SUNXI_SPRITE_ENV_SETTINGS	\
 	"bootdelay=0\0" \
@@ -345,7 +358,8 @@
 	"sunxi_sprite_test=sprite_test read\0"
 
 #define CONFIG_BOOTDELAY	1
-#define CONFIG_BOOTCOMMAND	"nand read 50000000 boot;boota 50000000"
+//#define CONFIG_BOOTCOMMAND	"nand read 50000000 boot;boota 50000000"
+#define CONFIG_BOOTCOMMAND     "if mmc rescan && fatload mmc 1 0x42000000 boot.scr; then source 0x42000000; else run bootcmdnormal; fi" 
 #define CONFIG_SYS_BOOT_GET_CMDLINE
 #define CONFIG_AUTO_COMPLETE
 
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/include/environment.h patched_uboot-sunxi-r16/include/environment.h
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/include/environment.h	2022-10-07 03:35:16.000000000 +0000
+++ patched_uboot-sunxi-r16/include/environment.h	2022-10-17 14:25:51.145557174 +0000
@@ -107,6 +107,7 @@
 #ifdef CONFIG_ENV_IS_EMBEDDED
 # if !defined(CONFIG_ENV_IS_IN_FLASH) && \
      !defined(CONFIG_ENV_IS_IN_NAND) && \
+     !defined(CONFIG_ENV_IS_IN_NAND_SUNXI) && \
      !defined(CONFIG_ENV_IS_IN_ONENAND) && \
      !defined(CONFIG_ENV_IS_IN_SPI_FLASH)
 #  error "CONFIG_ENV_IS_EMBEDDED not supported for your flash type"
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/Makefile patched_uboot-sunxi-r16/Makefile
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/Makefile	2022-10-07 03:35:16.000000000 +0000
+++ patched_uboot-sunxi-r16/Makefile	2022-10-19 16:54:53.399426672 +0000
@@ -112,8 +112,8 @@
 SRCTREE		:= $(CURDIR)
 TOPDIR		:= $(SRCTREE)
 LNDIR		:= $(OBJTREE)
-SPLDIR          := $(OBJTREE)/../bootloader/sunxi_spl
-SPLBASE         := $(OBJTREE)/../bootloader
+SPLDIR          := $(OBJTREE)/sunxi_spl
+SPLBASE         := $(OBJTREE)/
 SPLSUPPORT  := $(shell if [ -d $(SPLBASE) ] ; then echo "y"; else echo "n"; fi)
 export	TOPDIR SRCTREE OBJTREE SPLTREE SPLBASE SPLDIR
 
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/libs/check.c patched_uboot-sunxi-r16/sunxi_spl/boot0/libs/check.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/libs/check.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/boot0/libs/check.c	2022-10-17 16:23:17.915852184 +0000
@@ -0,0 +1,177 @@
+/*
+************************************************************************************************************************
+*                                          Boot rom
+*                                         Seucre Boot
+*
+*                             Copyright(C), 2006-2013, AllWinners Microelectronic Co., Ltd.
+*											       All Rights Reserved
+*
+* File Name   : Base.h
+*
+* Author      : glhuang
+*
+* Version     : 0.0.1
+*
+* Date        : 2013.09.05
+*
+* Description :
+*
+* Others      : None at present.
+*
+*
+* History     :
+*
+*  <Author>        <time>       <version>      <description>
+*
+* glhuang       2013.09.05       0.0.1        build the file
+*
+************************************************************************************************************************
+*/
+#include "common.h"
+#include "private_toc.h"
+
+//#pragma arm section  code="check_magic"
+/********************************************************************************
+*函数名称: check_magic
+*函数原型: __s32 check_magic( __u32 *mem_base, const char *magic )
+*函数功能: 使用“算术和”来校验内存中的一段数据
+*入口参数: mem_base       Boot文件在内存中的起始地址
+*          magic          Boot的magic
+*返 回 值: CHECK_IS_CORRECT      校验正确
+*          CHECK_IS_WRONG        校验错误
+*备    注:
+********************************************************************************/
+__s32 check_magic( __u32 *mem_base, const char *magic )
+{
+	struct spare_boot_head_t *bfh;
+
+	bfh = (struct spare_boot_head_t *)mem_base;
+	if(!(strncmp((const char *)bfh->boot_head.magic, magic, 8)))
+	{
+		return 0;
+	}
+
+	return -1;
+}
+
+//#pragma arm section
+
+
+
+
+//#pragma arm section  code="check_sum"
+/********************************************************************************
+*函数名称: check_sum
+*函数原型: __s32 check_sum( __u32 *mem_base, __u32 size, const char *magic )
+*函数功能: 使用“算术和”来校验内存中的一段数据
+*入口参数: mem_base           待校验的数据在内存中的起始地址（必须是4字节对齐的）
+*          size               待校验的数据的个数（以字节为单位，必须是4字节对齐的）
+*返 回 值: CHECK_IS_CORRECT   校验正确
+*          CHECK_IS_WRONG     校验错误
+*备    注:
+********************************************************************************/
+__s32 check_sum( __u32 *mem_base, __u32 size )
+{
+	__u32 *buf;
+	__u32 count;
+	__u32 src_sum;
+	__u32 sum;
+	struct spare_boot_head_t  *bfh;
+
+
+	bfh = (struct spare_boot_head_t *)mem_base;
+
+	/* 生成校验和 */
+	src_sum = bfh->boot_head.check_sum;                  // 从Boot_file_head中的“check_sum”字段取出校验和
+	bfh->boot_head.check_sum = STAMP_VALUE;              // 将STAMP_VALUE写入Boot_file_head中的“check_sum”字段
+
+	count = size >> 2;                         // 以 字（4bytes）为单位计数
+	sum = 0;
+	buf = (__u32 *)mem_base;
+	do
+	{
+		sum += *buf++;                         // 依次累加，求得校验和
+		sum += *buf++;                         // 依次累加，求得校验和
+		sum += *buf++;                         // 依次累加，求得校验和
+		sum += *buf++;                         // 依次累加，求得校验和
+	}while( ( count -= 4 ) > (4-1) );
+
+	while( count-- > 0 )
+		sum += *buf++;
+
+	bfh->boot_head.check_sum = src_sum;                  // 恢复Boot_file_head中的“check_sum”字段的值
+
+	printf("sum=%x\n", sum);
+	printf("src_sum=%x\n", src_sum);
+
+	if( sum == src_sum )
+		return 0;               // 校验成功
+	else
+		return -1;                 // 校验失败
+}
+
+//#pragma arm section
+
+
+
+//#pragma arm section  code="check_file"
+/********************************************************************************
+*函数名称: check_file
+*函数原型: __s32 check_file( __u32 *mem_base, __u32 size, const char *magic )
+*函数功能: 使用“算术和”来校验内存中的一段数据
+*入口参数: mem_base       待校验的数据在内存中的起始地址（必须是4字节对齐的）
+*          size           待校验的数据的个数（以字节为单位，必须是4字节对齐的）
+*          magic          magic number, 待校验文件的标识码
+*返 回 值: CHECK_IS_CORRECT       校验正确
+*          CHECK_IS_WRONG         校验错误
+*备    注:
+********************************************************************************/
+__s32 check_file( __u32 *mem_base, __u32 size, const char *magic )
+{
+	if( check_magic( mem_base, magic ) == 0
+        &&check_sum( mem_base, size  ) == 0 )
+        return 0;
+    else
+    	return -1;
+}
+
+
+int verify_addsum( void *mem_base, __u32 size )
+{
+	__u32 *buf;
+	__u32 count;
+	__u32 src_sum;
+	__u32 sum;
+	struct spare_boot_head_t  *bfh;
+
+
+	bfh = (struct spare_boot_head_t *)mem_base;
+
+	/* 生成校验和 */
+	src_sum = bfh->boot_head.check_sum;                  // 从Boot_file_head中的“check_sum”字段取出校验和
+	bfh->boot_head.check_sum = STAMP_VALUE;              // 将STAMP_VALUE写入Boot_file_head中的“check_sum”字段
+
+	count = size >> 2;                         // 以 字（4bytes）为单位计数
+	sum = 0;
+	buf = (__u32 *)mem_base;
+	do
+	{
+		sum += *buf++;                         // 依次累加，求得校验和
+		sum += *buf++;                         // 依次累加，求得校验和
+		sum += *buf++;                         // 依次累加，求得校验和
+		sum += *buf++;                         // 依次累加，求得校验和
+	}while( ( count -= 4 ) > (4-1) );
+
+	while( count-- > 0 )
+		sum += *buf++;
+
+	bfh->boot_head.check_sum = src_sum;                  // 恢复Boot_file_head中的“check_sum”字段的值
+
+	printf("sum=%x\n", sum);
+	printf("src_sum=%x\n", src_sum);
+
+	if( sum == src_sum )
+		return 0;               // 校验成功
+	else
+		return -1;                 // 校验失败
+}
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/libs/common.c patched_uboot-sunxi-r16/sunxi_spl/boot0/libs/common.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/libs/common.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/boot0/libs/common.c	2022-10-17 16:23:17.915852184 +0000
@@ -0,0 +1,76 @@
+/*
+ * (C) Copyright 2007-2013
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Young <guoyingyang@allwinnertech.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "common.h"
+#include "asm/armv7.h"
+#include <private_boot0.h>
+
+extern const boot0_file_head_t  BT0_head;
+extern int debug_mode;
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :set_debugmode_flag
+*
+*    parmeters     :void
+*
+*    return        :
+*
+*    note          :if BT0_head.prvt_head.debug_mode_off = 1,do not print any message to uart
+*
+*
+************************************************************************************************************
+*/
+
+#include <asm/arch/uart.h>
+
+void set_debugmode_flag(void)
+{
+        char c = 0;
+        int i = 0;
+        for( i = 0 ; i < 3 ; i++)
+        {
+                __msdelay(10);
+                if(sunxi_serial_tstc())
+                {
+                        printf("key_press  \n");
+                        c = sunxi_serial_getc();
+                        printf("0x%x \n",c);
+                        break;
+                }
+        }
+        if(c  == 's')
+        {
+                debug_mode = 1;
+                return ;
+        }
+	if(BT0_head.prvt_head.debug_mode)
+		debug_mode = 1;
+	else
+		debug_mode = 0;
+	return ;
+
+}
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/libs/jmp.c patched_uboot-sunxi-r16/sunxi_spl/boot0/libs/jmp.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/libs/jmp.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/boot0/libs/jmp.c	2022-10-17 16:23:17.915852184 +0000
@@ -0,0 +1,50 @@
+/*
+**********************************************************************************************************************
+*
+*						           the Embedded Secure Bootloader System
+*
+*
+*						       Copyright(C), 2006-2014, Allwinnertech Co., Ltd.
+*                                           All Rights Reserved
+*
+* File    :
+*
+* By      :
+*
+* Version : V2.00
+*
+* Date	  :
+*
+* Descript:
+**********************************************************************************************************************
+*/
+#include "common.h"
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+void boot0_jump(unsigned int addr)
+{
+	//asm volatile("mrs r1, cpsr");
+	//asm volatile("bic r1, r1, #(1<<5)");
+	//asm volatile("bic r1, r1, #(1<<24)");
+	//asm volatile("msr spsr_cxsf, r1");
+	asm volatile("mov r2, #0");
+    asm volatile("mcr p15, 0, r2, c7, c5, 6");
+
+	asm volatile("bx r0");
+}
+
+
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/libs/Makefile patched_uboot-sunxi-r16/sunxi_spl/boot0/libs/Makefile
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/libs/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/boot0/libs/Makefile	2022-10-17 16:23:17.915852184 +0000
@@ -0,0 +1,35 @@
+
+##
+## Makefile for Sunxi Secure Boot
+##
+
+
+
+include $(TOPDIR)/config.mk
+
+LIB	:= $(obj)libgeneric.o
+
+COBJS += check.o
+COBJS += nand_misc.o
+COBJS += mmu.o
+COBJS += eabi_compat.o
+COBJS += common.o
+
+SOBJS   := $(SOBJS)
+COBJS	:= $(COBJS)
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/libs/mmu.c patched_uboot-sunxi-r16/sunxi_spl/boot0/libs/mmu.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/libs/mmu.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/boot0/libs/mmu.c	2022-10-17 16:23:17.915852184 +0000
@@ -0,0 +1,123 @@
+/*
+ * (C) Copyright 2007-2013
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Jerry Wang <wangflord@allwinnertech.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "common.h"
+#include "asm/armv7.h"
+#include "asm/arch/timer.h"
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+void mmu_setup(void)
+{
+	u32 mmu_base;
+#ifdef CONFIG_ARCH_SUN8IW8P1
+	u32 *page_table = (u32 *)BOOT0_SYS_MMU_BASE;
+#else
+	u32 *page_table = (u32 *)CONFIG_SYS_SRAMA2_BASE;
+#endif
+        int i;
+	u32 reg;
+
+	page_table[0] = (3 << 10) | (15 << 5) | (1 << 3) | (0 << 2) | 0x2;
+	/* the front 1G of memory(treated as 4G for all) is set up as none cacheable */
+	for (i = 1; i < (CONFIG_SYS_SDRAM_BASE>>20); i++)
+		page_table[i] = (i << 20) | (3 << 10) | (15 << 5) | (0 << 3) | 0x2;
+	/* Set up as write through and buffered(not write back) for other 3GB, rw for everyone */
+	for (i = (CONFIG_SYS_SDRAM_BASE>>20); i < 4096; i++)
+		page_table[i] = (i << 20) | (3 << 10) | (15 << 5) | (1 << 3) | (0 << 2) | 0x2;
+	/* flush tlb */
+	asm volatile("mcr p15, 0, %0, c8, c7, 0" : : "r" (0));
+	/* Copy the page table address to cp15 */
+#ifdef CONFIG_ARCH_SUN8IW8P1
+	mmu_base = BOOT0_SYS_MMU_BASE;
+#else
+	mmu_base = CONFIG_SYS_SRAMA2_BASE;
+#endif
+        mmu_base |= (1 << 0) | (1 << 1) | (2 << 3);
+	asm volatile("mcr p15, 0, %0, c2, c0, 0"
+		     : : "r" (mmu_base) : "memory");
+	asm volatile("mcr p15, 0, %0, c2, c0, 1"
+		     : : "r" (mmu_base) : "memory");
+	/* Set the access control to all-supervisor */
+	asm volatile("mcr p15, 0, %0, c3, c0, 0"
+		     : : "r" (0x55555555));			//modified, origin value is (~0)
+	asm volatile("isb");
+	/* and enable the mmu */
+	asm volatile("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (reg) : : "cc");
+
+	__usdelay(100);
+	reg |= 1;    //enable mmu
+	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR" : : "r" (reg) : "cc");
+	asm volatile("isb");
+}
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+void  mmu_turn_off( void )
+{
+	uint reg;
+	/* and disable the mmu */
+	asm volatile("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (reg) : : "cc");
+	__usdelay(100);
+	reg &= ~((7<<0)|(1<<12));    //disable mmu
+	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR" : : "r" (reg) : "cc");
+	asm volatile("isb");
+	/*
+	 * Invalidate all instruction caches to PoU.
+	 * Also flushes branch target cache.
+	 */
+	asm volatile ("mcr p15, 0, %0, c7, c5, 0" : : "r" (0));
+	/* Invalidate entire branch predictor array */
+	asm volatile ("mcr p15, 0, %0, c7, c5, 6" : : "r" (0));
+	/* Full system DSB - make sure that the invalidation is complete */
+	CP15DSB;
+	/* ISB - make sure the instruction stream sees it */
+	CP15ISB;
+}
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/libs/nand_misc.c patched_uboot-sunxi-r16/sunxi_spl/boot0/libs/nand_misc.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/libs/nand_misc.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/boot0/libs/nand_misc.c	2022-10-17 16:23:17.915852184 +0000
@@ -0,0 +1,125 @@
+/*
+**********************************************************************************************************************
+*
+*						           the Embedded Secure Bootloader System
+*
+*
+*						       Copyright(C), 2006-2014, Allwinnertech Co., Ltd.
+*                                           All Rights Reserved
+*
+* File    :
+*
+* By      :
+*
+* Version : V2.00
+*
+* Date	  :
+*
+* Descript:
+**********************************************************************************************************************
+*/
+#include "common.h"
+#include <private_boot0.h>
+#include <private_uboot.h>
+#include <asm/arch/dram.h>
+#include <asm/arch/clock.h>
+
+extern const boot0_file_head_t  BT0_head;
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+int BOOT_NandGetPara(void *param, uint size)
+{
+    memcpy( (void *)param, BT0_head.prvt_head.storage_data, size);
+
+	return 0;
+}
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+__u8  *get_page_buf( void )
+{
+
+	return (__u8 *)(CONFIG_SYS_SDRAM_BASE + 1024 * 1024);
+}
+
+/*******************************************************************************
+*函数名称: g_mod
+*函数原型：uint32 g_mod( __u32 dividend, __u32 divisor, __u32 *quot_p )
+*函数功能: 从nand flash的某一块中找到一个完好备份将其载入到RAM中。如果成功，返
+*          回OK；否则，返回ERROR。
+*入口参数: dividend          输入。被除数
+*          divisor           输入。除数
+*          quot_p            输出。商
+*返 回 值: 余数
+*******************************************************************************/
+__u32 g_mod( __u32 dividend, __u32 divisor, __u32 *quot_p )
+{
+	if( divisor == 0 )
+	{
+		*quot_p = 0;
+		return 0;
+	}
+	if( divisor == 1 )
+	{
+		*quot_p = dividend;
+		return 0;
+	}
+
+	for( *quot_p = 0; dividend >= divisor; ++(*quot_p) )
+		dividend -= divisor;
+	return dividend;
+}
+
+
+void set_dram_para(void *dram_addr , __u32 dram_size, __u32 boot_cpu)
+{
+	__dram_para_t   *dram_para = (__dram_para_t *)dram_addr;
+	struct spare_boot_head_t  *uboot_buf = (struct spare_boot_head_t *)CONFIG_SYS_TEXT_BASE;
+#if defined (CONFIG_ARCH_SUN7I) || defined(CONFIG_ARCH_SUN5I)
+	dram_para->dram_size = dram_size;
+#else
+	dram_para->dram_para1 &= 0xffff0000;
+	dram_para->dram_para1 |= (dram_size & 0xffff);
+#endif
+	memcpy((void *)uboot_buf->boot_data.dram_para, dram_addr, 32 * sizeof(int));
+#ifdef CONFIG_BOOT_A15
+	uboot_buf->boot_data.reserved[0] = boot_cpu;
+#endif
+	return;
+}
+
+
+void cpu_init_s(void)
+{
+	timer_init();
+
+	set_pll();
+}
+
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/libs/sbrom_libs.h patched_uboot-sunxi-r16/sunxi_spl/boot0/libs/sbrom_libs.h
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/libs/sbrom_libs.h	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/boot0/libs/sbrom_libs.h	2022-10-17 16:23:17.915852184 +0000
@@ -0,0 +1,40 @@
+/*
+**********************************************************************************************************************
+*
+*						           the Embedded Secure Bootloader System
+*
+*
+*						       Copyright(C), 2006-2014, Allwinnertech Co., Ltd.
+*                                           All Rights Reserved
+*
+* File    :
+*
+* By      :
+*
+* Version : V2.00
+*
+* Date	  :
+*
+* Descript:
+**********************************************************************************************************************
+*/
+#ifndef  __SBORM_LIBS_H__
+#define  __SBORM_LIBS_H__
+
+
+extern void mmu_setup(void);
+extern void mmu_turn_off(void);
+
+extern int create_heap(unsigned int pHeapHead, unsigned int nHeapSize);
+
+extern unsigned int go_exec (unsigned int run_addr, unsigned int para_addr, int out_secure);
+
+extern void boot0_jump(unsigned int addr);
+
+extern void set_dram_para(void *dram_addr , __u32 dram_size, __u32 boot_cpu);
+
+extern __s32 check_sum( __u32 *mem_base, __u32 size );
+extern __s32 check_magic( __u32 *mem_base, const char *magic );
+
+#endif
+
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/load_mmc/load_boot1_from_sdmmc.c patched_uboot-sunxi-r16/sunxi_spl/boot0/load_mmc/load_boot1_from_sdmmc.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/load_mmc/load_boot1_from_sdmmc.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/boot0/load_mmc/load_boot1_from_sdmmc.c	2022-10-17 16:23:17.915852184 +0000
@@ -0,0 +1,205 @@
+/*
+************************************************************************************************************************
+*                                                         eGON
+*                                         the Embedded GO-ON Bootloader System
+*
+*                             Copyright(C), 2006-2009, SoftWinners Microelectronic Co., Ltd.
+*											       All Rights Reserved
+*
+* File Name   : load_boot1_from_sdmmc.c
+*
+* Author      : Gary.Wang
+*
+* Version     : 1.1.0
+*
+* Date        : 2009.12.08
+*
+* Description :
+*
+* Others      : None at present.
+*
+*
+* History     :
+*
+*  <Author>        <time>       <version>      <description>
+*
+* Gary.Wang      2009.12.08       1.1.0        build the file
+*
+************************************************************************************************************************
+*/
+#include "common.h"
+#include "spare_head.h"
+#include "private_boot0.h"
+#include "private_uboot.h"
+#include <asm/arch/mmc_boot0.h>
+
+extern __s32 check_magic( __u32 *mem_base, const char *magic );
+extern __s32 check_sum( __u32 *mem_base, __u32 size );
+
+extern const boot0_file_head_t  BT0_head;
+
+
+typedef struct _boot_sdcard_info_t
+{
+	__s32               card_ctrl_num;                //总共的卡的个数
+	__s32				boot_offset;                  //指定卡启动之后，逻辑和物理分区的管理
+	__s32 				card_no[4];                   //当前启动的卡号, 16-31:GPIO编号，0-15:实际卡控制器编号
+	__s32 				speed_mode[4];                //卡的速度模式，0：低速，其它：高速
+	__s32				line_sel[4];                  //卡的线制，0: 1线，其它，4线
+	__s32				line_count[4];                //卡使用线的个数
+	__s32  	        	sdc_2xmode[4];
+	__s32		        ddrmode[4];
+        __s32                   sdc_f_max[4];        
+}
+boot_sdcard_info_t;
+
+extern const boot0_file_head_t  BT0_head;
+/*******************************************************************************
+*函数名称: load_boot1_from_sdmmc
+*函数原型：int32 load_boot1_from_sdmmc( __u8 card_no )
+*函数功能: 将一份好的Boot1从sdmmc flash中载入到SRAM中。
+*入口参数: void
+*返 回 值: OK                         载入并校验成功
+*          ERROR                      载入并校验失败
+*备    注:
+*******************************************************************************/
+__s32 load_boot1_from_sdmmc( char *buf)
+{
+    __u32  length;
+    __s32  card_no, i;
+	struct spare_boot_head_t  *bfh = (struct spare_boot_head_t *) CONFIG_SYS_TEXT_BASE;;
+	boot_sdcard_info_t  *sdcard_info = (boot_sdcard_info_t *)buf;
+
+	i = BT0_head.boot_head.platform[0];
+	printf("card boot number = %d\n", i);
+
+	for(i=0;i<4;i++)
+	{
+		/* open sdmmc */
+		card_no = i;
+		printf("card no is %d\n", card_no);
+		if(card_no < 0)
+		{
+			printf("bad card number %d in card boot\n", card_no);
+
+			goto __card_op_fail__;
+		}
+		printf("sdcard %d line count %d\n", card_no, sdcard_info->line_sel[i] );
+		if(!sdcard_info->line_sel[i])
+		{
+			sdcard_info->line_sel[i] = 4;
+		}
+		if( sunxi_mmc_init( card_no, sdcard_info->line_sel[i], BT0_head.prvt_head.storage_gpio, 16 ,(void *)(sdcard_info)) == -1)   //高速卡，4线配置
+		{
+			printf("Fail in Init sdmmc.\n");
+			goto __card_op_fail__;
+		}
+		printf("sdcard %d init ok\n", card_no);
+#ifndef CONFIG_SUNXI_SECURE_SYSTEM
+		/* load 1k uboot head */
+	    if( mmc_bread( card_no, UBOOT_START_SECTOR_IN_SDMMC, 1024/512, (void *)CONFIG_SYS_TEXT_BASE ) != (1024/512))
+		{
+			printf("Fail in reading uboot head.\n");
+			goto __card_op_fail__;
+		}
+		/* check head */
+		if( check_magic( (__u32 *)CONFIG_SYS_TEXT_BASE, UBOOT_MAGIC ) != 0 )
+		{
+			printf("ERROR! NOT find the head of uboot.\n");
+			goto __card_op_fail__;
+		}
+		/* check length */
+	    length =  bfh->boot_head.length;
+		printf("The size of uboot is %x.\n", length );
+	    if( ( length & ( 8 * 1024 - 1 ) ) != 0 )
+	    {
+	    	printf("boot0 length is NOT align.\n");
+	    	goto __card_op_fail__;
+	    }
+	    if( mmc_bread( card_no, UBOOT_START_SECTOR_IN_SDMMC, length/512, (void *)CONFIG_SYS_TEXT_BASE )!= (length/512))
+		{
+			printf("Fail in reading uboot head.\n");
+			goto __card_op_fail__;
+		}
+		/* 检查校验和 */
+	    if( check_sum( (__u32 *)CONFIG_SYS_TEXT_BASE, length ) != 0 )
+	    {
+	        printf("Fail in checking uboot.\n");
+	       	goto __card_op_fail__;
+	    }
+#else
+		uint start_sector = UBOOT_START_SECTOR_IN_SDMMC - (UBOOT_START_SECTOR_PRE_IN_SDMMC - UBOOT_START_SECTOR_IN_SDMMC);
+
+		do
+		{
+			start_sector += UBOOT_START_SECTOR_PRE_IN_SDMMC - UBOOT_START_SECTOR_IN_SDMMC;
+
+			if(start_sector > UBOOT_START_SECTOR_PRE_IN_SDMMC)
+			{
+				printf("read all u-boot blk failed\n");
+
+				goto __card_op_fail__;
+			}
+			/* load 1k uboot head */
+		    if( mmc_bread( card_no, start_sector, 1024/512, (void *)CONFIG_SYS_TEXT_BASE ) != (1024/512))
+			{
+				printf("Fail in reading uboot head.\n");
+				continue;
+			}
+			/* check head */
+			if( check_magic( (__u32 *)CONFIG_SYS_TEXT_BASE, UBOOT_MAGIC ) != 0 )
+			{
+				printf("ERROR! NOT find the head of uboot.\n");
+				continue;
+			}
+			/* check length */
+		    length =  bfh->boot_head.length;
+			printf("The size of uboot is %x.\n", length );
+		    if( ( length & ( 8 * 1024 - 1 ) ) != 0 )
+		    {
+		    	printf("boot0 length is NOT align.\n");
+		    	continue;
+		    }
+		    if( mmc_bread( card_no, start_sector, length/512, (void *)CONFIG_SYS_TEXT_BASE )!= (length/512))
+			{
+				printf("Fail in reading uboot head.\n");
+				continue;
+			}
+			/* 检查校验和 */
+		    if( check_sum( (__u32 *)CONFIG_SYS_TEXT_BASE, length ) != 0 )
+		    {
+		        printf("Fail in checking uboot.\n");
+		       	continue;
+		    }
+		    break;
+		}
+		while(1);
+#endif
+		if(i == 0)
+		{
+			bfh->boot_data.storage_type = 1;
+		}
+		else
+		{
+			bfh->boot_data.storage_type = 2;
+			set_mmc_para(2,(void *)&BT0_head.prvt_head.storage_data);
+		}
+		printf("Succeed in loading uboot from sdmmc flash.\n");
+
+		sunxi_mmc_exit( card_no, BT0_head.prvt_head.storage_gpio, 16 );
+
+		return 0;
+
+__card_op_fail__:
+		sunxi_mmc_exit(card_no, BT0_head.prvt_head.storage_gpio, 16 );
+	}
+
+	return -1;
+}
+
+int load_boot1(void)
+{
+	memcpy((void *)DRAM_PARA_STORE_ADDR, (void *)BT0_head.prvt_head.dram_para, SUNXI_DRAM_PARA_MAX * 4);
+
+	return load_boot1_from_sdmmc((char *)BT0_head.prvt_head.storage_data);
+}
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/load_mmc/Makefile patched_uboot-sunxi-r16/sunxi_spl/boot0/load_mmc/Makefile
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/load_mmc/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/boot0/load_mmc/Makefile	2022-10-17 16:23:17.915852184 +0000
@@ -0,0 +1,29 @@
+
+##
+## Makefile for Sunxi Secure Boot
+##
+
+
+
+include $(TOPDIR)/config.mk
+
+LIB	:= $(obj)libloadmmc.o
+
+COBJS-y += load_boot1_from_sdmmc.o
+
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+
+all:	 $(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/load_nand/load_Boot1_from_nand.c patched_uboot-sunxi-r16/sunxi_spl/boot0/load_nand/load_Boot1_from_nand.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/load_nand/load_Boot1_from_nand.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/boot0/load_nand/load_Boot1_from_nand.c	2022-10-17 16:23:17.915852184 +0000
@@ -0,0 +1,146 @@
+/*
+************************************************************************************************************************
+*                                                         eGON
+*                                         the Embedded GO-ON Bootloader System
+*
+*                             Copyright(C), 2006-2008, SoftWinners Microelectronic Co., Ltd.
+*											       All Rights Reserved
+*
+* File Name : load_Boot1_from_nand.c
+*
+* Author : Gary.Wang
+*
+* Version : 1.1.0
+*
+* Date : 2007.10.14
+*
+* Description : This file provides a function "load_Boot1_from_nand" to load a good copy of Boot1
+*             from outside nand flash chips to SRAM.
+*
+* Others : None at present.
+*
+*
+* History :
+*
+*  <Author>        <time>       <version>      <description>
+*
+* Gary.Wang       2007.10.14      1.1.0        build the file
+*
+************************************************************************************************************************
+*/
+//#include "load_Boot1_from_nand_i.h"
+#include "common.h"
+#include "spare_head.h"
+#include "private_uboot.h"
+#include "asm/arch/nand_boot0.h"
+#include "../libs/sbrom_libs.h"
+
+
+/*******************************************************************************
+*函数名称: load_Boot1_from_nand
+*函数原型：int32 load_Boot1_from_nand( void )
+*函数功能: 将一份好的Boot1从nand flash中载入到SRAM中。
+*入口参数: void
+*返 回 值: OK                         载入并校验成功
+*          ERROR                      载入并校验失败
+*备    注:
+*******************************************************************************/
+__s32 load_Boot1_from_nand( void )
+{
+    __u32 i;
+    __s32  status;
+    __u32 length;
+    __u32 read_blks;
+	struct spare_boot_head_t  *bfh = (struct spare_boot_head_t *) CONFIG_SYS_TEXT_BASE;;
+
+
+	if(NF_open( ) == NF_ERROR)                         // 打开nand flash
+	{
+		printf("fail in opening nand flash\n");
+
+		return -1;
+	}
+	//printf("Succeed in opening nand flash.\n");
+	printf("block from %d to %d\n", BOOT1_START_BLK_NUM, BOOT1_LAST_BLK_NUM);
+    for( i = BOOT1_START_BLK_NUM;  i <= BOOT1_LAST_BLK_NUM;  i++ )
+    {
+    	if( NF_read_status( i ) == NF_BAD_BLOCK )		// 如果当前块是坏块，则进入下一块
+    	{
+    		printf("nand block %d is bad\n", i);
+            continue;
+		}
+        /* 载入当前块最前面512字节的数据到SRAM中，目的是获取文件头 */
+        if( NF_read( i * ( NF_BLOCK_SIZE >> NF_SCT_SZ_WIDTH ), (void *)CONFIG_SYS_TEXT_BASE, 1 )  == NF_OVERTIME_ERR )
+        {
+		    printf("the first data is error\n");
+			continue;
+		}
+		//printf("Succeed in reading Boot1 file head.\n");
+
+		/* 察看是否是文件头 */
+		if( check_magic( (__u32 *)CONFIG_SYS_TEXT_BASE, UBOOT_MAGIC ) != 0 )
+		{
+			printf("ERROR! block %u doesn't store head of Boot1 copy.\n", i );
+			continue;
+		}
+
+        length =  bfh->boot_head.length;
+        //printf("The size of Boot1 is %x.\n", length );
+        //printf("The align size of Boot1 is %x.\n", NF_SECTOR_SIZE );
+        if( ( length & ( NF_SECTOR_SIZE - 1 ) ) != 0 )     // length必须是NF_SECTOR_SIZE对齐的
+        {
+            printf("the boot1 is not aligned by %x\n", bfh->boot_head.align_size);
+        	continue;
+		}
+		//printf("The size of Boot1 is %x.\n", length );
+        if( 1==load_uboot_in_one_block_judge(length) )
+        {
+        	/* 从一个块中载入Boot1的备份 */
+        	status = load_and_check_in_one_blk( i, (void *)CONFIG_SYS_TEXT_BASE, length, NF_BLOCK_SIZE );
+        	if( status == ADV_NF_OVERTIME_ERR )            // 块数不足
+        		continue;
+        	else if( status == ADV_NF_OK )
+        	{
+                //printf("Check is correct.\n");
+                bfh->boot_data.storage_type = 0;
+                NF_close( );                        // 关闭nand flash
+                return 0;
+            }
+        }
+        else
+        {
+        	/* 从多个块中载入一份Boot1的备份 */
+        	status = load_in_many_blks( i, BOOT1_LAST_BLK_NUM, (void*)CONFIG_SYS_TEXT_BASE,
+        								length, NF_BLOCK_SIZE, &read_blks );
+        	if( status == ADV_NF_LACK_BLKS )        // 块数不足
+        	{
+        		printf("ADV_NF_LACK_BLKS\n");
+        		NF_close( );                        // 关闭nand flash
+        		return -1;
+        	}
+        	else if( status == ADV_NF_OVERTIME_ERR )
+        	{
+        		printf("mult block ADV_NF_OVERTIME_ERR\n");
+        		continue;
+			}
+            if( check_sum( (__u32 *)CONFIG_SYS_TEXT_BASE, length ) == 0 )
+            {
+                printf("The file stored in start block %u is perfect.\n", i );
+                bfh->boot_data.storage_type = 0;
+                NF_close( );                        // 关闭nand flash
+                return 0;
+            }
+        }
+    }
+
+
+	printf("Can't find a good Boot1 copy in nand.\n");
+    NF_close( );                        // 关闭nand flash
+    printf("Ready to quit \"load_Boot1_from_nand\".\n");
+    return -1;
+}
+
+int load_boot1(void)
+{
+	return load_Boot1_from_nand();
+}
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/load_nand/Makefile patched_uboot-sunxi-r16/sunxi_spl/boot0/load_nand/Makefile
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/load_nand/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/boot0/load_nand/Makefile	2022-10-17 16:23:17.915852184 +0000
@@ -0,0 +1,29 @@
+
+##
+## Makefile for Sunxi Secure Boot
+##
+
+
+
+include $(TOPDIR)/config.mk
+
+LIB	:= $(obj)libloadnand.o
+
+COBJS-y += load_Boot1_from_nand.o
+
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+
+all:	 $(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/load_spinor/load_boot1_from_spinor.c patched_uboot-sunxi-r16/sunxi_spl/boot0/load_spinor/load_boot1_from_spinor.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/load_spinor/load_boot1_from_spinor.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/boot0/load_spinor/load_boot1_from_spinor.c	2022-10-17 16:23:17.915852184 +0000
@@ -0,0 +1,105 @@
+/*
+ * (C) Copyright 2012
+ *     wangflord@allwinnertech.com
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program;
+ *
+ */
+#include "common.h"
+#include "spare_head.h"
+#include "private_boot0.h"
+#include "private_uboot.h"
+#include <asm/arch/spinor.h>
+#include "../libs/sbrom_libs.h"
+
+extern const boot0_file_head_t  BT0_head;
+
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+int load_boot1_from_spinor(void)
+{
+	__u32 length;
+	struct spare_boot_head_t  *bfh;
+
+	if(spinor_init(0))
+	{
+		printf("spinor init fail\n");
+
+		return -1;
+	}
+	/* 载入当前块最前面512字节的数据到SRAM中，目的是获取文件头 */
+	if(spinor_read(UBOOT_START_SECTOR_IN_SPINOR, 1, (void *)CONFIG_SYS_TEXT_BASE ) )
+	{
+		printf("the first data is error\n");
+
+		goto __load_boot1_from_spinor_fail;
+	}
+	printf("Succeed in reading Boot1 file head.\n");
+
+	/* 察看是否是文件头 */
+	if( check_magic( (__u32 *)CONFIG_SYS_TEXT_BASE, UBOOT_MAGIC ) != 0 )
+	{
+		printf("ERROR! Add %u doesn't store head of Boot1 copy.\n", UBOOT_START_SECTOR_IN_SPINOR );
+
+		goto __load_boot1_from_spinor_fail;
+	}
+
+	bfh = (struct spare_boot_head_t *)CONFIG_SYS_TEXT_BASE;
+	length =  bfh->boot_head.length;
+	printf("The size of uboot is %x.\n", length );
+	if( ( length & ( 512 - 1 ) ) != 0 ) 	// length必须是NF_SECTOR_SIZE对齐的
+	{
+		printf("the boot1 is not aligned by %x\n", bfh->boot_head.align_size);
+
+		goto __load_boot1_from_spinor_fail;
+	}
+
+	if(spinor_read(UBOOT_START_SECTOR_IN_SPINOR, length/512, (void *)CONFIG_SYS_TEXT_BASE ))
+	{
+		printf("spinor read data	error\n");
+
+		goto __load_boot1_from_spinor_fail;
+	}
+	bfh->boot_data.storage_type = 3;
+
+	return 0;
+
+__load_boot1_from_spinor_fail:
+
+	return -1;
+}
+
+int load_boot1(void)
+{
+	//memcpy((void *)DRAM_PARA_STORE_ADDR, (void *)BT0_head.prvt_head.dram_para, SUNXI_DRAM_PARA_MAX * 4);
+
+	return load_boot1_from_spinor();
+}
+
+
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/load_spinor/Makefile patched_uboot-sunxi-r16/sunxi_spl/boot0/load_spinor/Makefile
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/load_spinor/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/boot0/load_spinor/Makefile	2022-10-17 16:23:17.915852184 +0000
@@ -0,0 +1,29 @@
+
+##
+## Makefile for Sunxi Secure Boot
+##
+
+
+
+include $(TOPDIR)/config.mk
+
+LIB	:= $(obj)libloadspinor.o
+
+COBJS-y += load_boot1_from_spinor.o
+
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+
+all:	 $(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/main/boot0_entry.S patched_uboot-sunxi-r16/sunxi_spl/boot0/main/boot0_entry.S
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/main/boot0_entry.S	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/boot0/main/boot0_entry.S	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,44 @@
+
+
+#include <config.h>
+#include "asm/mode.h"
+
+.globl _start
+_start: b	reset
+
+reset:
+	mrs r0, cpsr
+	bic r0, r0, #ARMV7_MODE_MASK
+	orr r0, r0, #ARMV7_SVC_MODE
+	orr r0, r0, #( ARMV7_IRQ_MASK | ARMV7_FIQ_MASK )    @// After reset, ARM automaticly disables IRQ and FIQ, and runs in SVC mode.
+	bic r0, r0, #(1<<9)                                 @// set little-endian
+	msr cpsr_c, r0
+
+	mrc	p15, 0, r0, c1, c0, 0
+	bic	r0, r0, #0x00002000	@ clear bits 13 (--V-)
+	bic	r0, r0, #0x00000007	@ clear bits 2:0 (-CAM)
+	orr	r0, r0, #0x00000800	@ set bit 11 (Z---) BTB
+	bic	r0, r0, #0x00001000	@ clear bit 12 (I) I-cache
+	mcr	p15, 0, r0, c1, c0, 0
+
+	ldr sp, =CONFIG_BOOT0_STACK_BOTTOM
+	bl  cpu_init_s
+
+	bl  clear_bss
+	bl  main
+
+clear_bss:
+	ldr	r0, =__bss_start
+	ldr	r1, =__bss_end
+
+	mov	r2, #0x00000000		/* clear			    */
+
+clbss_l:
+	str	r2, [r0]		/* clear loop...		    */
+	add	r0, r0, #4
+	cmp	r0, r1
+	bne	clbss_l
+
+	mov pc, lr
+
+
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/main/boot0_hash.c patched_uboot-sunxi-r16/sunxi_spl/boot0/main/boot0_hash.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/main/boot0_hash.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/boot0/main/boot0_hash.c	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,25 @@
+/*
+ * (C) Copyright 2007-2013
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Jerry Wang <wangflord@allwinnertech.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+ #include <common.h>
+ char boot0_hash_value[64] = {0x38};
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/main/boot0_head.c patched_uboot-sunxi-r16/sunxi_spl/boot0/main/boot0_head.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/main/boot0_head.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/boot0/main/boot0_head.c	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,98 @@
+/*
+************************************************************************************************************************
+*                                                         eGON
+*                                         the Embedded GO-ON Bootloader System
+*
+*                             Copyright(C), 2006-2008, SoftWinners Microelectronic Co., Ltd.
+*											       All Rights Reserved
+*
+* File Name : Boot0_head.c
+*
+* Author : Gary.Wang
+*
+* Version : 1.1.0
+*
+* Date : 2007.11.06
+*
+* Description : This file defines the file head part of Boot0, which contains some important
+*             infomations such as magic, platform infomation and so on, and MUST be allocted in the
+*             head of Boot0.
+*
+* Others : None at present.
+*
+*
+* History :
+*
+*  <Author>        <time>       <version>      <description>
+*
+* Gary.Wang       2007.11.06      1.1.0        build the file
+*
+************************************************************************************************************************
+*/
+#include "common.h"
+#include <private_boot0.h>
+
+extern char boot0_hash_value[64];
+const boot0_file_head_t  BT0_head = {
+	                                  {
+	      /* jump_instruction */          ( 0xEA000000 | ( ( ( sizeof( boot0_file_head_t ) + sizeof(boot0_hash_value)+ sizeof( int ) - 1 ) / sizeof( int ) - 2 ) & 0x00FFFFFF ) ),
+							   		      BOOT0_MAGIC,
+							   		      STAMP_VALUE,
+#ifdef ALIGN_SIZE_8K
+									      0x2000,
+#else
+                                          0x4000,
+#endif
+							   		      sizeof( boot_file_head_t ),
+							   		      {
+							   		      	0, 0, 1, 0
+							   		      },
+							   		      CONFIG_BOOT0_RET_ADDR,
+							   		      CONFIG_BOOT0_RUN_ADDR,
+							   		      0,
+							   		      {
+							   		      	0, 0, '4','.','2','.','0',0
+							   		      },
+							 	      },
+
+							 	  };
+
+
+
+/*******************************************************************************
+*
+*                  关于Boot_file_head中的jump_instruction字段
+*
+*  jump_instruction字段存放的是一条跳转指令：( B  BACK_OF_Boot_file_head )，此跳
+*转指令被执行后，程序将跳转到Boot_file_head后面第一条指令。
+*
+*  ARM指令中的B指令编码如下：
+*          +--------+---------+------------------------------+
+*          | 31--28 | 27--24  |            23--0             |
+*          +--------+---------+------------------------------+
+*          |  cond  | 1 0 1 0 |        signed_immed_24       |
+*          +--------+---------+------------------------------+
+*  《ARM Architecture Reference Manual》对于此指令有如下解释：
+*  Syntax :
+*  B{<cond>}  <target_address>
+*    <cond>    Is the condition under which the instruction is executed. If the
+*              <cond> is ommitted, the AL(always,its code is 0b1110 )is used.
+*    <target_address>
+*              Specified the address to branch to. The branch target address is
+*              calculated by:
+*              1.  Sign-extending the 24-bit signed(wro's complement)immediate
+*                  to 32 bits.
+*              2.  Shifting the result left two bits.
+*              3.  Adding to the contents of the PC, which contains the address
+*                  of the branch instruction plus 8.
+*
+*  由此可知，此指令编码的最高8位为：0b11101010，低24位根据Boot_file_head的大小动
+*态生成，所以指令的组装过程如下：
+*  ( sizeof( boot_file_head_t ) + sizeof( int ) - 1 ) / sizeof( int )
+*                                              求出文件头占用的“字”的个数
+*  - 2                                         减去PC预取的指令条数
+*  & 0x00FFFFFF                                求出signed-immed-24
+*  | 0xEA000000                                组装成B指令
+*
+*******************************************************************************/
+
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/main/boot0.lds patched_uboot-sunxi-r16/sunxi_spl/boot0/main/boot0.lds
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/main/boot0.lds	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/boot0/main/boot0.lds	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,40 @@
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+SECTIONS
+{
+	. = BOOT0ADDR;
+	. = ALIGN(4);
+
+	.head   :
+	{
+		main/boot0_head.o	(.rodata)
+	}
+        .hash   :
+        {
+                main/boot0_hash.o       (.data)
+        }
+        . = ALIGN(1);
+	.text :
+	{
+		main/boot0_entry.o (.text)
+		*(.text)
+	}
+	. = ALIGN(16);
+  	.rodata : { *(.rodata) }
+	. = ALIGN(16);
+  	.data : { *(.data) }
+
+        . = ALIGN(4);
+	.bss :
+	{
+	    __bss_start = .;
+		*(.bss)
+	}
+	. = ALIGN(4);
+	__bss_end = .;
+
+	_end = .;
+}
+
+
+
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/main/boot0_main.c patched_uboot-sunxi-r16/sunxi_spl/boot0/main/boot0_main.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/main/boot0_main.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/boot0/main/boot0_main.c	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,331 @@
+/*
+**********************************************************************************************************************
+*
+*						           the Embedded Secure Bootloader System
+*
+*
+*						       Copyright(C), 2006-2014, Allwinnertech Co., Ltd.
+*                                           All Rights Reserved
+*
+* File    :
+*
+* By      :
+*
+* Version : V2.00
+*
+* Date	  :
+*
+* Descript:
+**********************************************************************************************************************
+*/
+#include <common.h>
+#include <private_boot0.h>
+#include <private_uboot.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/timer.h>
+#include <asm/arch/uart.h>
+#include <asm/arch/dram.h>
+#include <asm/arch/rtc_region.h>
+#include <asm/arch/gpio.h>
+#include "../libs/sbrom_libs.h"
+#ifdef CONFIG_BOOT_A15
+#include <asm/arch/cpu_switch.h>
+#endif
+
+extern const boot0_file_head_t  BT0_head;
+
+static void print_version(void);
+static void print_commit_log(void);
+static int boot0_clear_env(void);
+#ifdef	SUNXI_OTA_TEST
+static void print_ota_test(void);
+#endif
+static int boot0_check_uart_input(void);
+
+extern int load_boot1(void);
+
+extern void set_debugmode_flag(void);
+
+int uboot_workmode_usbback;
+
+void __attribute__((weak)) bias_calibration(void)
+{
+	return;
+}
+/*******************************************************************************
+*函数名称: Boot0_C_part
+*函数原型：void Boot0_C_part( void )
+*函数功能: Boot0中用C语言编写的部分的主流程
+*入口参数: void
+*返 回 值: void
+*备    注:
+*******************************************************************************/
+void main( void )
+{
+	__u32 status;
+	__s32 dram_size;
+	int   ddr_aotu_scan = 0;
+#ifdef CONFIG_BOOT_A15
+	special_gpio_cfg a15_power_gpio;	//a15 extern power enabel gpio
+#endif
+    __u32 fel_flag;
+	__u32 boot_cpu=0;
+
+	bias_calibration();
+    timer_init();
+    sunxi_serial_init( BT0_head.prvt_head.uart_port, (void *)BT0_head.prvt_head.uart_ctrl, 6 );
+        set_debugmode_flag();
+	if( BT0_head.prvt_head.enable_jtag )
+    {
+    	boot_set_gpio((normal_gpio_cfg *)BT0_head.prvt_head.jtag_gpio, 6, 1);
+    }
+	printf("HELLO! BOOT0 is starting!\n");
+	print_version();
+        print_commit_log();
+	boot0_check_uart_input();
+#ifdef	SUNXI_OTA_TEST
+	print_ota_test();
+#endif
+
+#ifdef CONFIG_ARCH_SUN7I
+	reset_cpux(1);
+#endif
+    fel_flag = rtc_region_probe_fel_flag();
+    if(fel_flag == SUNXI_RUN_EFEX_FLAG)
+    {
+        rtc_region_clear_fel_flag();
+    	printf("eraly jump fel\n");
+
+    	goto __boot0_entry_err0;
+    } else if (fel_flag == 0xADAD) {
+		uboot_workmode_usbback = 1;
+		printf("change to usb back\n");
+		rtc_region_clear_fel_flag();
+	}
+#ifdef CONFIG_BOOT_A15
+//	printf("BT0_head.boot_head.boot_cpu=0x%x\n", BT0_head.boot_head.boot_cpu);
+//	if(BT0_head.boot_head.boot_cpu)
+//	{
+//		fel_flag = BOOT_A7_FLAG;
+//	}
+//	else
+//	{
+//		fel_flag = BOOT_A15_FLAG;
+//	}
+/*
+    boot_cpu  含义
+
+	bit0~7                       bit8~15
+
+	0:不需要保存标志位           1:当前应该切换a15启动
+	1:通知u-boot保存             0:当前应该切换a7启动
+
+	每次从brom读取的boot_cpu只能是0x100或者0
+*/
+	boot_cpu = BT0_head.boot_head.boot_cpu;
+	a15_power_gpio = BT0_head.boot_head.a15_power_gpio;
+	if(fel_flag == BOOT_A15_FLAG)
+	{
+		rtc_region_clear_fel_flag();
+		if(boot_cpu == 0x00)    //如果原本是a7启动
+			boot_cpu = 0x101;   //a15启动，需要保存标志位
+
+		switch_to_a15(a15_power_gpio);
+	}
+	else if(fel_flag == BOOT_A7_FLAG)
+	{
+		rtc_region_clear_fel_flag();
+		if(boot_cpu == 0x100)      //如果原本是a15启动
+			boot_cpu = 0x01;       //a7启动，需要保存标志位
+	}
+	else
+	{
+		if(boot_cpu == 0x100)
+		{
+			switch_to_a15(a15_power_gpio);                //a15启动，不需要保存标志位
+		}
+		else
+		{
+			boot_cpu = 0x0;    //a7启动，不需要保存标志位
+		}
+	}
+//  printf("BT0_head.boot_head.boot_cpu=0x%x\n", BT0_head.boot_head.boot_cpu);
+#endif
+	mmu_setup();
+
+    ddr_aotu_scan = 0;
+	dram_size = init_DRAM(ddr_aotu_scan, (void *)BT0_head.prvt_head.dram_para);
+	if(dram_size)
+	{
+	    //mdfs_save_value();
+		printf("dram size =%d\n", dram_size);
+	}
+	else
+	{
+		printf("initializing SDRAM Fail.\n");
+
+		goto  __boot0_entry_err;
+	}
+#if defined(CONFIG_ARCH_SUN9IW1P1)
+	__msdelay(100);
+#endif
+
+#ifdef CONFIG_ARCH_SUN7I
+    check_super_standby_flag();
+#endif
+
+	status = load_boot1();
+
+	printf("Ready to disable icache.\n");
+
+	mmu_turn_off( );                               // disable instruction cache
+
+	if( status == 0 )
+	{
+		//跳转之前，把所有的dram参数写到boot1中
+		set_dram_para((void *)&BT0_head.prvt_head.dram_para, dram_size, boot_cpu);
+		if(uboot_workmode_usbback) {
+			struct spare_boot_head_t  *bfh = (struct spare_boot_head_t *) CONFIG_SYS_TEXT_BASE;
+
+			bfh->boot_data.work_mode = WORK_MODE_USB_PRODUCT;
+		}
+
+		printf("Jump to secend Boot.\n");
+
+		boot0_jump(CONFIG_SYS_TEXT_BASE);		  // 如果载入Boot1成功，跳转到Boot1处执行
+	}
+
+__boot0_entry_err:
+#ifdef CONFIG_BOOT_A15
+	if(!(boot_cpu & 0xff00))
+	{
+		boot0_clear_env();
+
+		boot0_jump(FEL_BASE);
+	}
+	else
+	{
+		rtc_region_set_flag(SUNXI_RUN_EFEX_FLAG);
+		boot0_clear_env();
+
+		watchdog_enable();
+	}
+#endif
+__boot0_entry_err0:
+	boot0_clear_env();
+
+	boot0_jump(FEL_BASE);
+}
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+static void print_version(void)
+{
+
+	printf("boot0 version : %s\n", BT0_head.boot_head.platform + 2);
+
+	return;
+}
+
+extern char boot0_hash_value[64];
+static void print_commit_log(void)
+{
+        printf("boot0 commit : %s \n",boot0_hash_value);
+
+        return ;
+}
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+static int boot0_clear_env(void)
+{
+
+	reset_pll();
+	mmu_turn_off();
+
+	__msdelay(10);
+
+	return 0;
+}
+
+
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+#ifdef	SUNXI_OTA_TEST
+static void print_ota_test(void)
+{
+	printf("*********************************************\n");
+	printf("*********************************************\n");
+	printf("*********************************************\n");
+	printf("*********************************************\n");
+	printf("********[OTA TEST]:update boot0 sucess*******\n");
+	printf("*********************************************\n");
+	printf("*********************************************\n");
+	printf("*********************************************\n");
+	printf("*********************************************\n");
+	return;
+}
+#endif
+
+static int boot0_check_uart_input(void)
+{
+        int c = 0;
+        int i = 0;
+        for(i = 0;i < 3;i++)
+        {
+                __msdelay(10);
+                if(sunxi_serial_tstc())
+                {
+                        c = sunxi_serial_getc();
+                        break;
+                }
+        }
+
+        if(c == '2')
+        {
+		printf("enter 0x%x,ready jump to fes\n", c-0x30);  // ASCII to decimal digit
+		boot0_clear_env();
+		boot0_jump(FEL_BASE);
+        }
+        return 0;
+}
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/main/Makefile patched_uboot-sunxi-r16/sunxi_spl/boot0/main/Makefile
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/main/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/boot0/main/Makefile	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,38 @@
+
+##
+## Makefile for Sunxi Secure Boot
+##
+
+
+
+include $(TOPDIR)/config.mk
+
+LIB	:= $(obj)libmain.o
+
+HEAD    := boot0_head.o
+
+DATA    := boot0_hash.o
+
+START	:= boot0_entry.o
+
+COBJS   += boot0_main.o
+
+SRCS	:= $(START:.o=.S) $(COBJS:.o=.c) $(HEAD:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(COBJS-y) $(SOBJS))
+HEAD    := $(addprefix $(obj),$(HEAD))
+START	:= $(addprefix $(obj),$(START))
+DATA	:= $(addprefix $(obj),$(DATA))
+
+all:	 $(obj).depend $(HEAD) $(START) $(LIB) $(DATA)
+
+$(LIB):	$(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/main/old_boot0_head.c patched_uboot-sunxi-r16/sunxi_spl/boot0/main/old_boot0_head.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/main/old_boot0_head.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/boot0/main/old_boot0_head.c	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,98 @@
+/*
+************************************************************************************************************************
+*                                                         eGON
+*                                         the Embedded GO-ON Bootloader System
+*
+*                             Copyright(C), 2006-2008, SoftWinners Microelectronic Co., Ltd.
+*											       All Rights Reserved
+*
+* File Name : Boot0_head.c
+*
+* Author : Gary.Wang
+*
+* Version : 1.1.0
+*
+* Date : 2007.11.06
+*
+* Description : This file defines the file head part of Boot0, which contains some important
+*             infomations such as magic, platform infomation and so on, and MUST be allocted in the
+*             head of Boot0.
+*
+* Others : None at present.
+*
+*
+* History :
+*
+*  <Author>        <time>       <version>      <description>
+*
+* Gary.Wang       2007.11.06      1.1.0        build the file
+*
+************************************************************************************************************************
+*/
+#include "common.h"
+#include <private_boot0.h>
+
+extern char boot0_hash_value[64];
+const boot0_file_head_t  BT0_head = {
+	                                  {
+	      /* jump_instruction */          ( 0xEA000000 | ( ( ( sizeof( boot0_file_head_t ) + sizeof(boot0_hash_value)+ sizeof( int ) - 1 ) / sizeof( int ) - 2 ) & 0x00FFFFFF ) ),
+							   		      BOOT0_MAGIC,
+							   		      STAMP_VALUE,
+#ifdef ALIGN_SIZE_8K
+									      0x2000,
+#else
+                                          0x4000,
+#endif
+							   		      sizeof( boot_file_head_t ),
+							   		      {
+							   		      	0, 0, 1, 0
+							   		      },
+							   		      CONFIG_BOOT0_RET_ADDR,
+							   		      CONFIG_BOOT0_RUN_ADDR,
+							   		      0,
+							   		      {
+							   		      	0, 0, '4','.','2','.','0',0
+							   		      },
+							 	      },
+
+							 	  };
+
+
+
+/*******************************************************************************
+*
+*                  关于Boot_file_head中的jump_instruction字段
+*
+*  jump_instruction字段存放的是一条跳转指令：( B  BACK_OF_Boot_file_head )，此跳
+*转指令被执行后，程序将跳转到Boot_file_head后面第一条指令。
+*
+*  ARM指令中的B指令编码如下：
+*          +--------+---------+------------------------------+
+*          | 31--28 | 27--24  |            23--0             |
+*          +--------+---------+------------------------------+
+*          |  cond  | 1 0 1 0 |        signed_immed_24       |
+*          +--------+---------+------------------------------+
+*  《ARM Architecture Reference Manual》对于此指令有如下解释：
+*  Syntax :
+*  B{<cond>}  <target_address>
+*    <cond>    Is the condition under which the instruction is executed. If the
+*              <cond> is ommitted, the AL(always,its code is 0b1110 )is used.
+*    <target_address>
+*              Specified the address to branch to. The branch target address is
+*              calculated by:
+*              1.  Sign-extending the 24-bit signed(wro's complement)immediate
+*                  to 32 bits.
+*              2.  Shifting the result left two bits.
+*              3.  Adding to the contents of the PC, which contains the address
+*                  of the branch instruction plus 8.
+*
+*  由此可知，此指令编码的最高8位为：0b11101010，低24位根据Boot_file_head的大小动
+*态生成，所以指令的组装过程如下：
+*  ( sizeof( boot_file_head_t ) + sizeof( int ) - 1 ) / sizeof( int )
+*                                              求出文件头占用的“字”的个数
+*  - 2                                         减去PC预取的指令条数
+*  & 0x00FFFFFF                                求出signed-immed-24
+*  | 0xEA000000                                组装成B指令
+*
+*******************************************************************************/
+
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/main/winter_boot0_head.c patched_uboot-sunxi-r16/sunxi_spl/boot0/main/winter_boot0_head.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/main/winter_boot0_head.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/boot0/main/winter_boot0_head.c	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,473 @@
+/*
+************************************************************************************************************************
+*                                                         eGON
+*                                         the Embedded GO-ON Bootloader System
+*
+*                             Copyright(C), 2006-2008, SoftWinners Microelectronic Co., Ltd.
+*											       All Rights Reserved
+*
+* File Name : Boot0_head.c
+*
+* Author : Gary.Wang
+*
+* Version : 1.1.0
+*
+* Date : 2007.11.06
+*
+* Description : This file defines the file head part of Boot0, which contains some important
+*             infomations such as magic, platform infomation and so on, and MUST be allocted in the
+*             head of Boot0.
+*
+* Others : None at present.
+*
+*
+* History :
+*
+*  <Author>        <time>       <version>      <description>
+*
+* Gary.Wang       2007.11.06      1.1.0        build the file
+*
+************************************************************************************************************************
+*/
+#include "common.h"
+#include <private_boot0.h>
+
+extern char boot0_hash_value[64];
+const boot0_file_head_t  BT0_head = {
+	                                  {
+	      /* jump_instruction */          ( 0xEA000000 | ( ( ( sizeof( boot0_file_head_t ) + sizeof(boot0_hash_value)+ sizeof( int ) - 1 ) / sizeof( int ) - 2 ) & 0x00FFFFFF ) ),
+							   		      BOOT0_MAGIC,
+							   		      STAMP_VALUE,
+#ifdef ALIGN_SIZE_8K
+									      0x2000,
+#else
+                                          0x4000,
+#endif
+							   		      sizeof( boot_file_head_t ),
+							   		      {
+							   		      	0, 0, 1, 0
+							   		      },
+							   		      CONFIG_BOOT0_RET_ADDR,
+							   		      CONFIG_BOOT0_RUN_ADDR,
+							   		      0,
+							   		      {
+							   		      	0, 0, '4','.','2','.','0',0
+							   		      },
+							 	      },
+									  
+									    {
+0, //prvt_head.prvt_head_size
+1, //prvt_head.debug_mode
+        {552,3,15355,1,284295680,0,7280,64,24,0,4661583,29501771,397379,0,0,0,0,0,0,0,0,0,168,67585,0,0,0,0,0,0,0,0},//prvt_head.dram_para
+0, //prvt_head.uart_port
+        {
+                {
+                6,//port
+                2,//port_num
+                3,//mul_sel
+                1,//pull
+                1,//drv_level
+                -1,//data
+                { 0, 0}//prvt_head.uart_ctrl[i].reserved[2]
+                },
+                {
+                6,//port
+                4,//port_num
+                3,//mul_sel
+                1,//pull
+                1,//drv_level
+                -1,//data
+                { 0, 0}//prvt_head.uart_ctrl[i].reserved[2]
+                }
+        },//prvt_head.uart_ctrl[2]
+1, //prvt_head.enable_jtag
+        {
+                {
+                6,//port
+                0,//port_num
+                3,//mul_sel
+                1,//pull
+                1,//drv_level
+                -1,//data
+                { 0, 0}//prvt_head.jtag_gpio[i].reserved[2]
+                },
+                {
+                6,//port
+                5,//port_num
+                3,//mul_sel
+                1,//pull
+                1,//drv_level
+                -1,//data
+                { 0, 0}//prvt_head.jtag_gpio[i].reserved[2]
+                },
+                {
+                6,//port
+                3,//port_num
+                3,//mul_sel
+                1,//pull
+                1,//drv_level
+                -1,//data
+                { 0, 0}//prvt_head.jtag_gpio[i].reserved[2]
+                },
+                {
+                6,//port
+                1,//port_num
+                3,//mul_sel
+                1,//pull
+                1,//drv_level
+                -1,//data
+                { 0, 0}//prvt_head.jtag_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.jtag_gpio[i].reserved[2]
+                }
+        },//prvt_head.jtag_gpio
+        {
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                },
+                {
+                0,//port
+                0,//port_num
+                0,//mul_sel
+                0,//pull
+                0,//drv_level
+                0,//data
+                { 0, 0}//prvt_head.storage_gpio[i].reserved[2]
+                }
+        },//prvt_head.storage_gpio
+
+
+//this is prvt_head.storage_data
+
+        {
+1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,2,0,0,0,4,0,0,0,64,0,0,0,0,16,0,0,-116,0,0,0,30,0,0,0,0,0,0,0,-20,-36,16,-107,86,-1,-1,-1,-128,3,0,0,-128,3,0,0,0,0,0,0,0,0,0,0,8,0,0,0,40,0,0,0,46,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+        }
+
+					
+
+}
+
+};
+
+
+
+/*******************************************************************************
+*
+*                  关于Boot_file_head中的jump_instruction字段
+*
+*  jump_instruction字段存放的是一条跳转指令：( B  BACK_OF_Boot_file_head )，此跳
+*转指令被执行后，程序将跳转到Boot_file_head后面第一条指令。
+*
+*  ARM指令中的B指令编码如下：
+*          +--------+---------+------------------------------+
+*          | 31--28 | 27--24  |            23--0             |
+*          +--------+---------+------------------------------+
+*          |  cond  | 1 0 1 0 |        signed_immed_24       |
+*          +--------+---------+------------------------------+
+*  《ARM Architecture Reference Manual》对于此指令有如下解释：
+*  Syntax :
+*  B{<cond>}  <target_address>
+*    <cond>    Is the condition under which the instruction is executed. If the
+*              <cond> is ommitted, the AL(always,its code is 0b1110 )is used.
+*    <target_address>
+*              Specified the address to branch to. The branch target address is
+*              calculated by:
+*              1.  Sign-extending the 24-bit signed(wro's complement)immediate
+*                  to 32 bits.
+*              2.  Shifting the result left two bits.
+*              3.  Adding to the contents of the PC, which contains the address
+*                  of the branch instruction plus 8.
+*
+*  由此可知，此指令编码的最高8位为：0b11101010，低24位根据Boot_file_head的大小动
+*态生成，所以指令的组装过程如下：
+*  ( sizeof( boot_file_head_t ) + sizeof( int ) - 1 ) / sizeof( int )
+*                                              求出文件头占用的“字”的个数
+*  - 2                                         减去PC预取的指令条数
+*  & 0x00FFFFFF                                求出signed-immed-24
+*  | 0xEA000000                                组装成B指令
+*
+*******************************************************************************/
+
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/Makefile patched_uboot-sunxi-r16/sunxi_spl/boot0/Makefile
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/boot0/Makefile	2022-10-17 16:23:17.915852184 +0000
@@ -0,0 +1,130 @@
+#
+# (C) Copyright 2000-2011
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# (C) Copyright 2011
+# Daniel Schwierzeck, daniel.schwierzeck@googlemail.com.
+#
+# (C) Copyright 2011
+# Texas Instruments Incorporated - http://www.ti.com/
+# Aneesh V <aneesh@ti.com>
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Based on top-level Makefile.
+#
+
+include $(TOPDIR)/config.mk
+
+CONFIG_SPL := y
+export CONFIG_SPL
+
+TOOLS_DIR  := $(TOPDIR)/tools
+
+BOOT0_LDSCRIPT := $(TOPDIR)/sunxi_spl/boot0/main/boot0.lds
+
+
+# We want the final binaries in this directory
+obj := $(OBJTREE)/sunxi_spl/boot0/
+
+BOOT0_HEAD  := sunxi_spl/boot0/boot0_head.o
+START       := sunxi_spl/boot0/boot0_entry.o
+
+LIBS-y += sunxi_spl/boot0/spl/libsource_spl.o
+LIBS-y += sunxi_spl/boot0/main/libmain.o
+LIBS-y += sunxi_spl/boot0/libs/libgeneric.o
+LIBS-y += sunxi_spl/spl/lib/libgeneric.o
+LIBS-$(CONFIG_BOOT_A15) += arch/$(ARCH)/cpu/$(CPU)/$(SOC)/a15/liba15.o
+LIBS-y += arch/$(ARCH)/cpu/$(CPU)/$(SOC)/dram/libdram.o
+LIBS-$(CONFIG_SUNXI_CHIPID) += arch/$(ARCH)/cpu/$(CPU)/$(SOC)/dram/libchipid.o
+LIBS := $(addprefix $(OBJTREE)/,$(sort $(LIBS-y)))
+
+LIBNAND-$(CONFIG_STORAGE_MEDIA_NAND) += sunxi_spl/boot0/load_nand/libloadnand.o
+LIBNAND-$(CONFIG_STORAGE_MEDIA_NAND) += arch/$(ARCH)/cpu/$(CPU)/$(SOC)/nand/libnand.o
+
+LIBNAND := $(addprefix $(OBJTREE)/,$(sort $(LIBNAND-y)))
+
+LIBMMC-$(CONFIG_STORAGE_MEDIA_MMC) += sunxi_spl/boot0/load_mmc/libloadmmc.o
+LIBMMC-$(CONFIG_STORAGE_MEDIA_MMC) += arch/$(ARCH)/cpu/$(CPU)/$(SOC)/mmc/libmmc.o
+
+LIBMMC := $(addprefix $(OBJTREE)/,$(sort $(LIBMMC-y)))
+
+
+LIBSPINOR-$(CONFIG_STORAGE_MEDIA_SPINOR) += sunxi_spl/boot0/load_spinor/libloadspinor.o
+LIBSPINOR-$(CONFIG_STORAGE_MEDIA_SPINOR) += arch/$(ARCH)/cpu/$(CPU)/$(SOC)/spinor/libspinor.o
+
+LIBSPINOR := $(addprefix $(OBJTREE)/,$(sort $(LIBSPINOR-y)))
+
+__LIBS := $(subst $(obj),,$(LIBS))
+
+# Linker Script
+# ifdef CONFIG_SPL_LDSCRIPT
+# need to strip off double quotes
+# LDSCRIPT := $(addprefix $(SRCTREE)/,$(subst ",,$(CONFIG_SPL_LDSCRIPT)))
+# endif
+# ifeq ($(wildcard $(LDSCRIPT)),)
+# 	LDSCRIPT := $(TOPDIR)/board/$(BOARDDIR)/u-boot-spl.lds
+# endif
+# ifeq ($(wildcard $(LDSCRIPT)),)
+# 	LDSCRIPT := $(TOPDIR)/$(CPUDIR)/u-boot-spl.lds
+# endif
+# ifeq ($(wildcard $(LDSCRIPT)),)
+# $(error could not find linker script)
+# endif
+
+
+
+# Special flags for CPP when processing the linker script.
+# Pass the version down so we can handle backwards compatibility
+# on the fly.
+LDPPFLAGS += \
+	-include $(TOPDIR)/include/u-boot/u-boot.lds.h \
+	-DBOOT0ADDR=$(CONFIG_BOOT0_RUN_ADDR)	 \
+	$(shell $(LD) --version | \
+	  sed -ne 's/GNU ld version \([0-9][0-9]*\)\.\([0-9][0-9]*\).*/-DLD_MAJOR=\1 -DLD_MINOR=\2/p')
+
+ALL-$(CONFIG_STORAGE_MEDIA_NAND)  += $(obj)boot0_nand.bin 
+ALL-$(CONFIG_STORAGE_MEDIA_MMC)  += $(obj)boot0_sdcard.bin
+ALL-$(CONFIG_STORAGE_MEDIA_SPINOR)  += $(obj)boot0_spinor.bin
+
+all:	$(ALL-y)
+
+$(obj)boot0_nand.bin:	$(obj)boot0_nand.axf
+	$(OBJCOPY) $(OBJCFLAGS) -O binary  $< $@
+
+$(obj)boot0_nand.axf: depend $(LIBS) $(LIBNAND) $(obj)boot0.lds
+	$(LD) $(LIBS) $(LIBNAND) $(PLATFORM_LIBGCC) $(LDFLAGS) -T$(obj)boot0.lds -o boot0_nand.axf -Map boot0_nand.map
+
+$(obj)boot0_sdcard.bin:	$(obj)boot0_sdcard.axf
+	$(OBJCOPY) $(OBJCFLAGS) -O binary  $< $@
+
+$(obj)boot0_sdcard.axf: depend $(LIBS) $(LIBMMC) $(obj)boot0.lds
+	$(LD) $(LIBS) $(LIBMMC)  $(PLATFORM_LIBGCC) $(LDFLAGS) -T$(obj)boot0.lds -o boot0_sdcard.axf -Map boot0_sdcard.map
+
+$(obj)boot0_spinor.bin:	$(obj)boot0_spinor.axf
+	$(OBJCOPY) $(OBJCFLAGS) -O binary  $< $@
+
+$(obj)boot0_spinor.axf: depend $(LIBS) $(LIBSPINOR) $(obj)boot0.lds
+	$(LD) $(LIBS) $(LIBSPINOR)  $(PLATFORM_LIBGCC) $(LDFLAGS) -T$(obj)boot0.lds -o boot0_spinor.axf -Map boot0_spinor.map
+
+$(LIBS):	depend
+	$(MAKE) -C $(SRCTREE)$(dir $(subst $(OBJTREE),,$@))
+	
+$(LIBNAND): depend
+	$(MAKE) -C $(SRCTREE)$(dir $(subst $(OBJTREE),,$@))
+
+$(LIBMMC): depend
+	$(MAKE) -C $(SRCTREE)$(dir $(subst $(OBJTREE),,$@))
+
+$(LIBSPINOR): depend
+	$(MAKE) -C $(SRCTREE)$(dir $(subst $(OBJTREE),,$@))
+
+$(obj)boot0.lds: $(BOOT0_LDSCRIPT)
+	$(CPP) $(CPPFLAGS) $(LDPPFLAGS) -ansi -D__ASSEMBLY__ -P - <$^ >$@
+
+depend:	$(obj).depend
+.PHONY: depend
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/spl/Makefile patched_uboot-sunxi-r16/sunxi_spl/boot0/spl/Makefile
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/boot0/spl/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/boot0/spl/Makefile	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,53 @@
+#
+# (C) Copyright 2000-2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	=  $(obj)libsource_spl.o
+
+COBJS-y	+= $(TOPDIR)/arch/$(ARCH)/cpu/$(CPU)/$(SOC)/spl/rtc_region.o
+COBJS-y	+= $(TOPDIR)/arch/$(ARCH)/cpu/$(CPU)/$(SOC)/spl/timer_spl.o
+COBJS-y	+= $(TOPDIR)/arch/$(ARCH)/cpu/$(CPU)/$(SOC)/spl/gpio_spl.o
+COBJS-y	+= $(TOPDIR)/arch/$(ARCH)/cpu/$(CPU)/$(SOC)/spl/serial_spl.o
+COBJS-y	+= $(TOPDIR)/arch/$(ARCH)/cpu/$(CPU)/$(SOC)/spl/clock_spl.o
+COBJS-$(CONFIG_SUNXI_CHIPID)	+= $(TOPDIR)/arch/$(ARCH)/cpu/$(CPU)/$(SOC)/spl/efuse_spl.o
+
+#COBJS-$(CONFIG_XXXX)	+= xxxx.o
+COBJS	:= $(COBJS-y)
+
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+all:	 $(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/fes_init/main/fes1_entry.S patched_uboot-sunxi-r16/sunxi_spl/fes_init/main/fes1_entry.S
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/fes_init/main/fes1_entry.S	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/fes_init/main/fes1_entry.S	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,27 @@
+
+
+
+
+.globl _start
+_start: b	reset
+
+reset:
+	stmfd sp!, {lr}
+	bl  clear_bss
+	bl  main
+	ldmfd sp!, {lr}
+	mov pc, lr
+
+clear_bss:
+	ldr	r0, =__bss_start
+	ldr	r1, =__bss_end
+
+	mov	r2, #0x00000000		/* clear			    */
+
+clbss_l:
+	str	r2, [r0]		/* clear loop...		    */
+	add	r0, r0, #4
+	cmp	r0, r1
+	bne	clbss_l
+
+	mov pc, lr
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/fes_init/main/fes1_main.c patched_uboot-sunxi-r16/sunxi_spl/fes_init/main/fes1_main.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/fes_init/main/fes1_main.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/fes_init/main/fes1_main.c	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,129 @@
+/*
+**********************************************************************************************************************
+*
+*						           the Embedded Secure Bootloader System
+*
+*
+*						       Copyright(C), 2006-2014, Allwinnertech Co., Ltd.
+*                                           All Rights Reserved
+*
+* File    :
+*
+* By      :
+*
+* Version : V2.00
+*
+* Date	  :
+*
+* Descript:
+**********************************************************************************************************************
+*/
+#include <common.h>
+#include <private_boot0.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/timer.h>
+#include <asm/arch/uart.h>
+#include <asm/arch/dram.h>
+#include <asm/arch/ccmu.h>
+
+extern const boot0_file_head_t fes1_head;
+
+typedef struct __fes_aide_info{
+    __u32 dram_init_flag;       /* Dram初始化完成标志       */
+    __u32 dram_update_flag;     /* Dram 参数是否被修改标志  */
+    __u32 dram_paras[SUNXI_DRAM_PARA_MAX];
+}fes_aide_info_t;
+
+
+/*
+************************************************************************************
+*                          note_dram_log
+*
+* Description:
+*	    ???????
+* Parameters:
+*		void
+* Return value:
+*    	0: success
+*      !0: fail
+* History:
+*       void
+************************************************************************************
+*/
+static void  note_dram_log(int dram_init_flag)
+{
+    fes_aide_info_t *fes_aide = (fes_aide_info_t *)CONFIG_FES1_RET_ADDR;
+
+    memset(fes_aide, 0, sizeof(fes_aide_info_t));
+    fes_aide->dram_init_flag    = SYS_PARA_LOG;
+    fes_aide->dram_update_flag  = dram_init_flag;
+
+    memcpy(fes_aide->dram_paras, fes1_head.prvt_head.dram_para, SUNXI_DRAM_PARA_MAX * 4);
+    memcpy((void *)DRAM_PARA_STORE_ADDR, fes1_head.prvt_head.dram_para, SUNXI_DRAM_PARA_MAX * 4);
+}
+
+extern char fes_hash_value[64];
+static void print_commit_log(void)
+{
+        printf("fes commit : %s \n",fes_hash_value);
+}
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+int main(void)
+{
+	__s32 dram_size=0;
+
+	timer_init();
+#ifdef 	CONFIG_ARCH_SUN9IW1P1
+	if(readl(CCM_PLL1_C0_CTRL))
+	{
+		set_pll();
+	}
+#elif  defined(CONFIG_ARCH_SUN8IW6P1)
+	if(readl(CCMU_PLL_C0CPUX_CTRL_REG))
+	{
+		set_pll();
+	}
+#else
+	set_pll();
+#endif
+	//serial init
+	sunxi_serial_init(fes1_head.prvt_head.uart_port, (void *)fes1_head.prvt_head.uart_ctrl, 2);
+	//enable gpio gate
+	set_gpio_gate();
+        //print commit message
+        print_commit_log();
+	//dram init
+	printf("beign to init dram\n");
+	dram_size = init_DRAM(0, (void *)fes1_head.prvt_head.dram_para);
+	if (dram_size)
+	{
+		note_dram_log(1);
+		printf("init dram ok\n");
+	}
+	else
+	{
+		note_dram_log(0);
+		printf("init dram fail\n");
+	}
+
+	__msdelay(10);
+
+	return dram_size;
+}
+
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/fes_init/main/fes_hash.c patched_uboot-sunxi-r16/sunxi_spl/fes_init/main/fes_hash.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/fes_init/main/fes_hash.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/fes_init/main/fes_hash.c	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,25 @@
+/*
+ * (C) Copyright 2007-2013
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Jerry Wang <wangflord@allwinnertech.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+ #include <common.h>
+ char fes_hash_value[64] = {0x38};
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/fes_init/main/fes_head.c patched_uboot-sunxi-r16/sunxi_spl/fes_init/main/fes_head.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/fes_init/main/fes_head.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/fes_init/main/fes_head.c	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,104 @@
+/*
+************************************************************************************************************************
+*                                                         eGON
+*                                         the Embedded GO-ON Bootloader System
+*
+*                             Copyright(C), 2006-2008, SoftWinners Microelectronic Co., Ltd.
+*											       All Rights Reserved
+*
+* File Name : Boot0_head.c
+*
+* Author : Gary.Wang
+*
+* Version : 1.1.0
+*
+* Date : 2007.11.06
+*
+* Description : This file defines the file head part of Boot0, which contains some important
+*             infomations such as magic, platform infomation and so on, and MUST be allocted in the
+*             head of Boot0.
+*
+* Others : None at present.
+*
+*
+* History :
+*
+*  <Author>        <time>       <version>      <description>
+*
+* Gary.Wang       2007.11.06      1.1.0        build the file
+*
+************************************************************************************************************************
+*/
+#include "common.h"
+#include <private_boot0.h>
+
+extern char fes_hash[64] ;
+const boot0_file_head_t  fes1_head = {
+	                                  {
+	      /* jump_instruction */          ( 0xEA000000 | ( ( ( sizeof( boot0_file_head_t ) +sizeof(fes_hash)+ sizeof( int ) - 1 ) / sizeof( int ) - 2 ) & 0x00FFFFFF ) ),
+							   		      BOOT0_MAGIC,
+							   		      STAMP_VALUE,
+							   		      32,
+							   		      sizeof( boot_file_head_t ),
+										  {
+											0, 0, 0, 0
+										  },
+							   		      CONFIG_FES1_RET_ADDR,
+							   		      CONFIG_FES1_RUN_ADDR,
+							   		      0,
+							   		      {
+							   		      	0, 0, '3','.','0','.','0',0
+							   		      },
+							 	      },
+					{
+						sizeof(boot0_private_head_t),
+						0,
+						{
+							600,3,0x3bbb,1,
+							283246848,0,
+							7280,64,24,0,
+							0x47a14f,0x1c2294c,0x69049,0x0,0x0,0x0,0x0,
+							0x0,0x0,0x0,0x0,0x0,0xa8,0x10901
+						}
+					}
+							 	  };
+
+
+
+/*******************************************************************************
+*
+*                  关于Boot_file_head中的jump_instruction字段
+*
+*  jump_instruction字段存放的是一条跳转指令：( B  BACK_OF_Boot_file_head )，此跳
+*转指令被执行后，程序将跳转到Boot_file_head后面第一条指令。
+*
+*  ARM指令中的B指令编码如下：
+*          +--------+---------+------------------------------+
+*          | 31--28 | 27--24  |            23--0             |
+*          +--------+---------+------------------------------+
+*          |  cond  | 1 0 1 0 |        signed_immed_24       |
+*          +--------+---------+------------------------------+
+*  《ARM Architecture Reference Manual》对于此指令有如下解释：
+*  Syntax :
+*  B{<cond>}  <target_address>
+*    <cond>    Is the condition under which the instruction is executed. If the
+*              <cond> is ommitted, the AL(always,its code is 0b1110 )is used.
+*    <target_address>
+*              Specified the address to branch to. The branch target address is
+*              calculated by:
+*              1.  Sign-extending the 24-bit signed(wro's complement)immediate
+*                  to 32 bits.
+*              2.  Shifting the result left two bits.
+*              3.  Adding to the contents of the PC, which contains the address
+*                  of the branch instruction plus 8.
+*
+*  由此可知，此指令编码的最高8位为：0b11101010，低24位根据Boot_file_head的大小动
+*态生成，所以指令的组装过程如下：
+*  ( sizeof( boot_file_head_t ) + sizeof( int ) - 1 ) / sizeof( int )
+*                                              求出文件头占用的“字”的个数
+*  - 2                                         减去PC预取的指令条数
+*  & 0x00FFFFFF                                求出signed-immed-24
+*  | 0xEA000000                                组装成B指令
+*
+*******************************************************************************/
+
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/fes_init/main/fes_init.lds patched_uboot-sunxi-r16/sunxi_spl/fes_init/main/fes_init.lds
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/fes_init/main/fes_init.lds	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/fes_init/main/fes_init.lds	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,39 @@
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+SECTIONS
+{
+	. = FES1ADDR;
+	. = ALIGN(4);
+
+	.head   :
+	{
+		main/fes_head.o	(.rodata)
+	}
+	.hash	:
+	{
+		main/fes_hash.o (.data)
+	}
+	.text :
+	{
+		main/fes1_entry.o (.text)
+		*(.text)
+	}
+	. = ALIGN(16);
+  	.rodata : { *(.rodata) }
+	. = ALIGN(16);
+  	.data : { *(.data) }
+
+        . = ALIGN(4);
+	.bss :
+	{
+	__bss_start = .;
+		*(.bss)
+	}
+	. = ALIGN(4);
+	__bss_end = .;
+
+	_end = .;
+}
+
+
+
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/fes_init/main/Makefile patched_uboot-sunxi-r16/sunxi_spl/fes_init/main/Makefile
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/fes_init/main/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/fes_init/main/Makefile	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,39 @@
+
+##
+## Makefile for Sunxi Secure Boot
+##
+
+
+
+include $(TOPDIR)/config.mk
+
+LIB	:= $(obj)libmain.o
+
+HEAD    := fes_head.o
+
+START	:= fes1_entry.o
+
+COBJS   += fes1_main.o
+
+DATA 	:= fes_hash.o
+
+SRCS	:= $(START:.o=.S) $(COBJS:.o=.c) $(HEAD:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(COBJS-y) $(SOBJS))
+HEAD    := $(addprefix $(obj),$(HEAD))
+START	:= $(addprefix $(obj),$(START))
+DATA	:= $(addprefix $(obj),$(DATA))
+
+
+all:	 $(obj).depend $(HEAD) $(START) $(LIB) $(DATA)
+
+$(LIB):	$(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/fes_init/Makefile patched_uboot-sunxi-r16/sunxi_spl/fes_init/Makefile
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/fes_init/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/fes_init/Makefile	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,99 @@
+#
+# (C) Copyright 2000-2011
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# (C) Copyright 2011
+# Daniel Schwierzeck, daniel.schwierzeck@googlemail.com.
+#
+# (C) Copyright 2011
+# Texas Instruments Incorporated - http://www.ti.com/
+# Aneesh V <aneesh@ti.com>
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Based on top-level Makefile.
+#
+
+include $(TOPDIR)/config.mk
+
+CONFIG_SPL := y
+export CONFIG_SPL
+
+FES_LDSCRIPT := $(TOPDIR)/sunxi_spl/fes_init/main/fes_init.lds
+
+
+# We want the final binaries in this directory
+obj := $(OBJTREE)/sunxi_spl/fes_init/
+
+FES_HEAD  := main/fes_head.o
+START := main/fes1_entry.o
+
+LIBS-y += sunxi_spl/fes_init/spl/libsource_spl.o
+LIBS-y += sunxi_spl/fes_init/main/libmain.o
+LIBS-y += sunxi_spl/spl/lib/libgeneric.o
+LIBS-y += arch/$(ARCH)/cpu/$(CPU)/$(SOC)/dram/libdram.o
+
+LIBS-$(CONFIG_SUNXI_CHIPID) += arch/$(ARCH)/cpu/$(CPU)/$(SOC)/dram/libchipid.o
+
+LIBS := $(addprefix $(OBJTREE)/,$(sort $(LIBS-y)))
+
+
+__LIBS := $(subst $(obj),,$(LIBS))
+
+# Linker Script
+# ifdef CONFIG_SPL_LDSCRIPT
+# need to strip off double quotes
+# LDSCRIPT := $(addprefix $(SRCTREE)/,$(subst ",,$(CONFIG_SPL_LDSCRIPT)))
+# endif
+# ifeq ($(wildcard $(LDSCRIPT)),)
+# 	LDSCRIPT := $(TOPDIR)/board/$(BOARDDIR)/u-boot-spl.lds
+# endif
+# ifeq ($(wildcard $(LDSCRIPT)),)
+# 	LDSCRIPT := $(TOPDIR)/$(CPUDIR)/u-boot-spl.lds
+# endif
+# ifeq ($(wildcard $(LDSCRIPT)),)
+# $(error could not find linker script)
+# endif
+
+
+
+# Special flags for CPP when processing the linker script.
+# Pass the version down so we can handle backwards compatibility
+# on the fly.
+LDPPFLAGS += \
+	-include $(TOPDIR)/include/u-boot/u-boot.lds.h \
+	-DFES1ADDR=$(CONFIG_FES1_RUN_ADDR)	 \
+	$(shell $(LD) --version | \
+	  sed -ne 's/GNU ld version \([0-9][0-9]*\)\.\([0-9][0-9]*\).*/-DLD_MAJOR=\1 -DLD_MINOR=\2/p')
+
+ALL-y	+= $(obj)fes1.bin
+
+all:	$(ALL-y)
+
+
+$(obj)fes1.bin:	$(obj)fes1.axf
+	$(OBJCOPY) $(OBJCFLAGS) -O binary $< $@
+
+GEN_UBOOT = \
+	UNDEF_SYM=`$(OBJDUMP) -x $(LIBS) | \
+	sed  -n -e 's/.*\($(SYM_PREFIX)__u_boot_cmd_.*\)/-u\1/p'|sort|uniq`;\
+	cd $(obj) && $(LD) $(LDFLAGS) -T$(obj)fes_init.lds $(LDFLAGS_$(@F)) $$UNDEF_SYM  \
+	--start-group $(__LIBS) --end-group \
+	-Map fes1.map -o fes1.axf
+
+$(obj)fes1.axf: depend $(LIBS) $(obj)fes_init.lds
+	$(LD) $(LIBS) $(LDFLAGS) -T$(obj)fes_init.lds -o fes1.axf -Map fes1.map
+#	$(GEN_UBOOT)
+
+$(LIBS):	depend
+	$(MAKE) -C $(SRCTREE)$(dir $(subst $(OBJTREE),,$@))
+
+$(obj)fes_init.lds: $(FES_LDSCRIPT)
+	$(CPP) $(CPPFLAGS) $(LDPPFLAGS) -ansi -D__ASSEMBLY__ -P - <$^ >$@
+
+depend:	$(obj).depend
+.PHONY: depend
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/fes_init/spl/Makefile patched_uboot-sunxi-r16/sunxi_spl/fes_init/spl/Makefile
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/fes_init/spl/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/fes_init/spl/Makefile	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,52 @@
+#
+# (C) Copyright 2000-2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	=  $(obj)libsource_spl.o
+
+COBJS-y	+= $(TOPDIR)/arch/$(ARCH)/cpu/$(CPU)/$(SOC)/spl/timer_spl.o
+COBJS-y	+= $(TOPDIR)/arch/$(ARCH)/cpu/$(CPU)/$(SOC)/spl/gpio_spl.o
+COBJS-y	+= $(TOPDIR)/arch/$(ARCH)/cpu/$(CPU)/$(SOC)/spl/serial_spl.o
+COBJS-y	+= $(TOPDIR)/arch/$(ARCH)/cpu/$(CPU)/$(SOC)/spl/clock_spl.o
+COBJS-$(CONFIG_SUNXI_CHIPID)	+= $(TOPDIR)/arch/$(ARCH)/cpu/$(CPU)/$(SOC)/spl/efuse_spl.o
+
+#COBJS-$(CONFIG_XXXX)	+= xxxx.o
+COBJS	:= $(COBJS-y)
+
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+all:	 $(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/.gitignore patched_uboot-sunxi-r16/sunxi_spl/.gitignore
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/.gitignore	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/.gitignore	2022-10-17 16:23:17.915852184 +0000
@@ -0,0 +1,18 @@
+#
+# NOTE! Don't add files that are generated in specific
+# subdirectories here. Add them in the ".gitignore" file
+# in that subdirectory instead.
+#
+# Normal rules
+#
+
+*.rej
+*.axf
+*.map
+*.bin
+*.lds
+#
+# Generated files
+#
+
+
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/flash/flash.c patched_uboot-sunxi-r16/sunxi_spl/sbrom/flash/flash.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/flash/flash.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/sbrom/flash/flash.c	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,155 @@
+/*
+**********************************************************************************************************************
+*
+*						           the Embedded Secure Bootloader System
+*
+*
+*						       Copyright(C), 2006-2014, Allwinnertech Co., Ltd.
+*                                           All Rights Reserved
+*
+* File    :
+*
+* By      :
+*
+* Version : V2.00
+*
+* Date	  :
+*
+* Descript:
+**********************************************************************************************************************
+*/
+
+#include "common.h"
+#include "mmc.h"
+#include "spare_head.h"
+#include "private_toc.h"
+
+int sunxi_mmc_exit(int sdc_no, const normal_gpio_cfg *gpio_info, int offset);
+int sunxi_mmc_init(int sdc_no, unsigned bus_width, normal_gpio_cfg *gpio_info, int offset);
+unsigned long mmc_bread(int dev_num, unsigned long start, unsigned blkcnt, void *dst);
+int load_toc1_from_nand( void );
+
+extern sbrom_toc0_config_t *toc0_config;
+
+int load_toc1_from_sdmmc(int boot_type, int start_sector)
+{
+	u8  *tmp_buff = (u8 *)CONFIG_TOC1_STORE_IN_DRAM_BASE;
+	uint head_size;
+	sbrom_toc1_head_info_t	*toc1_head;
+	int  sunxi_flash_mmc_card_no;
+	int ret =0;
+
+	if(boot_type == BOOT_FROM_SD0)
+	{
+		sunxi_flash_mmc_card_no = 0;
+	}
+	else
+	{
+		sunxi_flash_mmc_card_no = 2;
+	}
+	ret = sunxi_mmc_init(sunxi_flash_mmc_card_no, 4, toc0_config->storage_gpio + 24, 8);
+	if(ret <= 0)
+	{
+		printf("sunxi_flash_init err: sunxi_mmc_init failed\n");
+		goto __ERROR_EXIT;;
+	}
+	//一次读取64k数据
+	ret = mmc_bread(sunxi_flash_mmc_card_no, start_sector, 64, tmp_buff);
+	if(!ret)
+	{
+		printf("PANIC : sunxi_flash_init() error --1--\n");
+		goto __ERROR_EXIT;
+	}
+	toc1_head = (struct sbrom_toc1_head_info *)tmp_buff;
+	if(toc1_head->magic != TOC_MAIN_INFO_MAGIC)
+	{
+		printf("PANIC : sunxi_flash_init() error --2--,toc1 magic error\n");
+		goto __ERROR_EXIT;
+	}
+	head_size = toc1_head->valid_len;
+	if(head_size > 64 * 512)
+	{
+		tmp_buff += 64*512;
+		ret = mmc_bread(sunxi_flash_mmc_card_no, start_sector + 64, (head_size - 64*512 + 511)/512, tmp_buff);
+		if(!ret)
+		{
+			printf("PANIC : sunxi_flash_init() error --3--\n");
+			goto __ERROR_EXIT;
+		}
+	}
+	sunxi_mmc_exit(sunxi_flash_mmc_card_no,toc0_config->storage_gpio + 24,8);
+	return 0;
+__ERROR_EXIT:
+	sunxi_mmc_exit(sunxi_flash_mmc_card_no,toc0_config->storage_gpio + 24,8);
+	return -1;
+
+}
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+//mode : 0 -- normal 1:backup
+int sunxi_flash_init(int boot_type, int start_sector)
+{
+	int ret;
+	if((boot_type == BOOT_FROM_SD0) || (boot_type == BOOT_FROM_SD2))
+	{
+		ret = load_toc1_from_sdmmc(boot_type,start_sector);
+		return ret;
+	}
+	else if(boot_type == BOOT_FROM_NFC)
+	{
+		if(load_toc1_from_nand())
+		{
+			printf("sunxi_flash_init err: nand init failed\n");
+
+			return -1;
+		}
+		return 0;
+	}
+	else if(boot_type == BOOT_FROM_SPI)
+	{
+		printf("PANIC:NVM_init() : spi not support now\n");
+		return -1;
+	}
+	else
+	{
+		printf("PANIC:NVM_init() : nvm_id = %d not support now\n",boot_type);
+
+		return -1;
+	}
+}
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+int sunxi_flash_read(u32 start_sector, u32 blkcnt, void *buff)
+{
+	memcpy(buff, (void *)(CONFIG_TOC1_STORE_IN_DRAM_BASE + 512 * start_sector), 512 * blkcnt);
+
+	return blkcnt;
+}
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/flash/Makefile patched_uboot-sunxi-r16/sunxi_spl/sbrom/flash/Makefile
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/flash/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/sbrom/flash/Makefile	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,31 @@
+
+##
+## Makefile for Sunxi Secure Boot
+##
+
+
+
+include $(TOPDIR)/config.mk
+
+LIB	:= $(obj)libflash.o
+
+COBJS += flash.o
+
+
+COBJS	:= $(COBJS)
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/libs/check.c patched_uboot-sunxi-r16/sunxi_spl/sbrom/libs/check.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/libs/check.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/sbrom/libs/check.c	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,71 @@
+/*
+************************************************************************************************************************
+*                                          Boot rom
+*                                         Seucre Boot
+*
+*                             Copyright(C), 2006-2013, AllWinners Microelectronic Co., Ltd.
+*											       All Rights Reserved
+*
+* File Name   : Base.h
+*
+* Author      : glhuang
+*
+* Version     : 0.0.1
+*
+* Date        : 2013.09.05
+*
+* Description :
+*
+* Others      : None at present.
+*
+*
+* History     :
+*
+*  <Author>        <time>       <version>      <description>
+*
+* glhuang       2013.09.05       0.0.1        build the file
+*
+************************************************************************************************************************
+*/
+#include "common.h"
+#include "private_toc.h"
+
+extern sbrom_toc0_config_t *toc0_config;
+
+int verify_addsum( void *mem_base, __u32 size )
+{
+	__u32 *buf;
+	__u32 count;
+	__u32 src_sum;
+	__u32 sum;
+	sbrom_toc1_head_info_t  *bfh;
+
+	bfh = (sbrom_toc1_head_info_t *)mem_base;
+
+	/* 生成校验和 */
+	src_sum = bfh->add_sum;                  // 从Boot_file_head中的“check_sum”字段取出校验和
+	bfh->add_sum = STAMP_VALUE;              // 将STAMP_VALUE写入Boot_file_head中的“check_sum”字段
+
+	count = size >> 2;                         // 以 字（4bytes）为单位计数
+	sum = 0;
+	buf = (__u32 *)mem_base;
+	do
+	{
+		sum += *buf++;                         // 依次累加，求得校验和
+		sum += *buf++;                         // 依次累加，求得校验和
+		sum += *buf++;                         // 依次累加，求得校验和
+		sum += *buf++;                         // 依次累加，求得校验和
+	}while( ( count -= 4 ) > (4-1) );
+
+	while( count-- > 0 )
+		sum += *buf++;
+
+	bfh->add_sum = src_sum;                  // 恢复Boot_file_head中的“check_sum”字段的值
+
+	if( sum == src_sum )
+		return 0;                           // 校验成功
+	else
+		return -1;                          // 校验失败
+}
+
+
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/libs/common.c patched_uboot-sunxi-r16/sunxi_spl/sbrom/libs/common.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/libs/common.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/sbrom/libs/common.c	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,76 @@
+/*
+ * (C) Copyright 2007-2013
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Young <guoyingyang@allwinnertech.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "common.h"
+#include "asm/armv7.h"
+#include <private_toc.h>
+#include <asm/arch/uart.h>
+
+extern sbrom_toc0_config_t *toc0_config ;
+extern int debug_mode;
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :set_debugmode_flag
+*
+*    parmeters     :void
+*
+*    return        :
+*
+*    note          :if BT0_head.prvt_head.debug_mode_off = 1,do not print any message to uart ;
+*                   if you press 's' button,turn on printf
+*
+************************************************************************************************************
+*/
+
+void set_debugmode_flag(void)
+{
+        char c = 0;
+        int i = 0;
+        for(i = 0;i < 3;i++)
+        {
+                __msdelay(10);
+                if(sunxi_serial_tstc())
+                {
+                        printf("key press :");
+                        c = sunxi_serial_getc();
+                        printf("0x%x   \n",c);
+                        break;
+                }
+        }
+        if(c  == 's')
+        {
+                debug_mode = 1;
+                return ;
+        }
+	if(toc0_config->debug_mode)
+		debug_mode = 1;
+	else
+		debug_mode = 0;
+	return ;
+
+}
+
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/libs/exec.c patched_uboot-sunxi-r16/sunxi_spl/sbrom/libs/exec.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/libs/exec.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/sbrom/libs/exec.c	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,106 @@
+/*
+**********************************************************************************************************************
+*
+*						           the Embedded Secure Bootloader System
+*
+*
+*						       Copyright(C), 2006-2014, Allwinnertech Co., Ltd.
+*                                           All Rights Reserved
+*
+* File    :
+*
+* By      :
+*
+* Version : V2.00
+*
+* Date	  :
+*
+* Descript:
+**********************************************************************************************************************
+*/
+#include "common.h"
+#include <asm/arch/smta.h>
+#include <asm/arch/smc.h>
+#include <asm/arch/mmc_boot0.h>
+#include <private_toc.h>
+#include <private_uboot.h>
+
+extern sbrom_toc0_config_t *toc0_config;
+
+void secure_switch_unsecure(u32 run_addr, u32 para_addr);
+void secure_switch_other(u32 run_addr, u32 para_addr);
+
+unsigned int go_exec (u32 run_addr, u32 para_addr, int out_secure)
+{
+	if(out_secure)
+	{
+		//切换到非安全模式
+		asm volatile("stmfd sp!, {r0, r1}");
+#ifdef CONFIG_OPTEE_SUPPORT
+		struct spare_boot_head_t *bfh = (struct spare_boot_head_t *)para_addr;
+#else
+		struct spare_boot_head_t *bfh = (struct spare_boot_head_t *)run_addr;
+#endif		
+		toc0_private_head_t *toc0 = (toc0_private_head_t *)CONFIG_SBROMSW_BASE;
+		int boot_type = toc0->platform[0];
+		int card_work_mode = toc0_config->card_work_mode;
+		uint dram_size;
+
+		if(!boot_type)
+		{
+			boot_type = 1;
+		}
+		else if(boot_type == 1)
+		{
+			boot_type = 0;
+		}else if(boot_type == 2){
+			//char  storage_data[384];  // 0-159,存储nand信息；160-255,存放卡信息^M
+			set_mmc_para(2,(void *)(toc0_config->storage_data+160));
+		}
+
+		printf("storage_type=%d\n", boot_type);
+		bfh->boot_data.storage_type = boot_type;
+		if(card_work_mode)
+		{
+			bfh->boot_data.work_mode = card_work_mode;
+			printf("card_work_mode=%d\n", card_work_mode);
+		}
+                if(out_secure == SECURE_SWITCH_NORMAL)
+                {
+                    bfh->boot_data.secureos_exist = 1;
+		    sunxi_smta_set_to_ns(0);
+                }
+		dram_size = toc0_config->dram_para[4] & 0xffff;
+                if(out_secure == SECURE_SWITCH_NORMAL)
+                {
+	    	    printf("dram =%d M, reserved size = %d M\n", dram_size, toc0_config->secure_dram_mbytes);
+		    sunxi_smc_config(dram_size, toc0_config->secure_dram_mbytes);
+		    printf("switch to ns\n");
+		    memcpy(bfh->boot_data.dram_para, toc0_config->dram_para, 32 * 4);
+		    bfh->boot_data.dram_para[4] -= toc0_config->secure_dram_mbytes;
+                }
+                else
+                {
+                    printf("still in secure world  \n");
+                    printf("dram = %d M \n",dram_size);
+                    bfh->boot_data.secureos_exist = 0;
+		    memcpy(bfh->boot_data.dram_para, toc0_config->dram_para, 32 * 4);
+                }
+#ifdef CONFIG_BOOT_A15
+		bfh->boot_data.reserved[0] = toc0_config->boot_cpu;
+#endif
+		asm volatile("ldmfd sp!, {r0, r1}");
+                if(out_secure == SECURE_SWITCH_NORMAL)
+		    asm volatile("bx %0"::"r" (secure_switch_unsecure));
+                else
+		    asm volatile("blx %0"::"r" (secure_switch_other));
+
+	}
+	else
+	{
+		asm volatile("blx %0"::"r" (secure_switch_other));
+	}
+
+	return 0;
+}
+
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/libs/Makefile patched_uboot-sunxi-r16/sunxi_spl/sbrom/libs/Makefile
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/libs/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/sbrom/libs/Makefile	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,38 @@
+
+##
+## Makefile for Sunxi Secure Boot
+##
+
+
+
+include $(TOPDIR)/config.mk
+
+LIB	:= $(obj)libgeneric.o
+
+SOBJS += switch2ns.o
+
+COBJS += exec.o
+COBJS += malloc.o
+COBJS += check.o
+COBJS += nand_misc.o
+COBJS += mmu.o
+COBJS += common.o
+
+SOBJS   := $(SOBJS)
+COBJS	:= $(COBJS)
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/libs/malloc.c patched_uboot-sunxi-r16/sunxi_spl/sbrom/libs/malloc.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/libs/malloc.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/sbrom/libs/malloc.c	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,213 @@
+/*
+**********************************************************************************************************************
+*											        eGon
+*						           the Embedded GO-ON Bootloader System
+*									       eGON memory sub-system
+*
+*						  Copyright(C), 2006-2010, SoftWinners Microelectronic Co., Ltd.
+*                                           All Rights Reserved
+*
+* File    : mem_alloc
+*
+* By      : Jerry
+*
+* Version : V2.00
+*
+* Date	  :
+*
+* Descript:
+**********************************************************************************************************************
+*/
+
+#include "common.h"
+
+struct alloc_struct_t
+{
+    __u32 address;                      //申请内存的地址
+    __u32 size;                         //分配的内存大小，用户实际得到的内存大小
+    __u32 o_size;                       //用户申请的内存大小
+    struct alloc_struct_t *next;
+};
+
+#define MY_BYTE_ALIGN(x)                ( ( (x + 15)/16) * 16)             /* alloc based on 1k byte */
+
+static struct alloc_struct_t boot_heap_head, boot_heap_tail;
+/*
+*********************************************************************************************************
+*                       CREATE HEAP
+*
+* Description: create heap.
+*
+* Aguments   : pHeapHead    heap start address.
+*              nHeapSize    heap size.
+*
+* Returns    : EPDK_OK/EPDK_FAIL.
+*********************************************************************************************************
+*/
+
+__s32 create_heap(__u32 pHeapHead, __u32 nHeapSize)
+{
+    boot_heap_head.size    = boot_heap_tail.size = 0;
+    boot_heap_head.address = pHeapHead;
+    boot_heap_tail.address = pHeapHead + nHeapSize;
+    boot_heap_head.next    = &boot_heap_tail;
+    boot_heap_tail.next    = 0;
+
+    return 0;
+}
+
+/*
+*********************************************************************************************************
+*                       MALLOC BUFFER FROM HEAP
+*
+* Description: malloc a buffer from heap.
+*
+* Aguments   : num_bytes    the size of the buffer need malloc;
+*
+* Returns    : the po__s32er to buffer has malloc.
+*********************************************************************************************************
+*/
+void *malloc(__u32 num_bytes)
+{
+    struct alloc_struct_t *ptr, *newptr;
+    __u32  actual_bytes;
+
+    if (!num_bytes) return 0;
+
+    actual_bytes = MY_BYTE_ALIGN(num_bytes);    /* translate the byte count to size of long type       */
+
+    ptr = &boot_heap_head;                      /* scan from the boot_heap_head of the heap            */
+
+    while (ptr && ptr->next)                    /* look for enough memory for alloc                    */
+    {
+        if (ptr->next->address >= (ptr->address + ptr->size +                                          \
+                2 * sizeof(struct alloc_struct_t) + actual_bytes))
+        {
+            break;
+        }
+                                                /* find enough memory to alloc                         */
+        ptr = ptr->next;
+    }
+
+    if (!ptr->next)
+    {
+        return 0;                   /* it has reached the boot_heap_tail of the heap now              */
+    }
+
+    newptr = (struct alloc_struct_t *)(ptr->address + ptr->size);
+                                                /* create a new node for the memory block             */
+    if (!newptr)
+    {
+        return 0;                               /* create the node failed, can't manage the block     */
+    }
+
+    /* set the memory block chain, insert the node to the chain */
+    newptr->address = ptr->address + ptr->size + sizeof(struct alloc_struct_t);
+    newptr->size    = actual_bytes;
+    newptr->o_size  = num_bytes;
+    newptr->next    = ptr->next;
+    ptr->next       = newptr;
+
+    return (void *)newptr->address;
+}
+/*
+*********************************************************************************************************
+*                       MALLOC BUFFER FROM HEAP
+*
+* Description: malloc a buffer from heap.
+*
+* Aguments   : num_bytes    the size of the buffer need malloc;
+*
+* Returns    : the po__s32er to buffer has malloc.
+*********************************************************************************************************
+*/
+void *realloc(void *p, __u32 num_bytes)
+{
+    struct alloc_struct_t *ptr, *prev;
+    void   *tmp;
+    __u32  actual_bytes;
+
+    if(!p)
+    {
+        return malloc(num_bytes);             /* 如果传进的指针是空，则按照传进的字节数申请内存    */
+    }
+    if (!num_bytes)
+    {
+        return p;                                   /* 如果申请追加的内存字节数是0，则直接返回当前的指针 */
+    }
+
+    ptr = &boot_heap_head;                          /* look for the node which po__s32 this memory block                   */
+    while (ptr && ptr->next)
+    {
+        if (ptr->next->address == (__u32)p)
+            break;                                  /* find the node which need to be release                              */
+        ptr = ptr->next;
+    }
+
+    //此时，ptr指向的是用户指针的前一个节点
+    prev = ptr;
+    ptr  = ptr->next;
+
+    if(!ptr)
+    {
+        return 0;                                   /* 如果没有找到用户传进的地址         */
+    }
+    //用ptr指向用户节点
+    actual_bytes = MY_BYTE_ALIGN(ptr->o_size + num_bytes);
+    if(actual_bytes == ptr->size)
+    {
+        return p;
+    }
+
+    tmp = malloc(actual_bytes);
+    if(!tmp)
+    {
+        return 0;
+    }
+    memcpy(tmp, (void *)ptr->address, ptr->size);
+    prev->next = ptr->next;     /* delete the node which need be released from the memory block chain  */
+
+    return tmp;
+}
+
+/*
+*********************************************************************************************************
+*                       FREE BUFFER TO HEAP
+*
+* Description: free buffer to heap
+*
+* Aguments   : p    the po__s32er to the buffer which need be free.
+*
+* Returns    : none
+*********************************************************************************************************
+*/
+void  free(void *p)
+{
+    struct alloc_struct_t *ptr, *prev;
+
+	if( p == NULL )
+		return;
+
+    ptr = &boot_heap_head;                /* look for the node which po__s32 this memory block                     */
+    while (ptr && ptr->next)
+    {
+        if (ptr->next->address == (__u32)p)
+            break;              /* find the node which need to be release                              */
+        ptr = ptr->next;
+    }
+
+	prev = ptr;
+	ptr = ptr->next;
+
+    if (!ptr) return;           /* the node is heap boot_heap_tail                                               */
+
+    prev->next = ptr->next;     /* delete the node which need be released from the memory block chain  */
+
+    return ;
+}
+
+
+
+
+
+
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/libs/mmu.c patched_uboot-sunxi-r16/sunxi_spl/sbrom/libs/mmu.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/libs/mmu.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/sbrom/libs/mmu.c	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,175 @@
+/*
+ * (C) Copyright 2007-2013
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Jerry Wang <wangflord@allwinnertech.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "common.h"
+#include "asm/armv7.h"
+#include "asm/arch/timer.h"
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+void mmu_setup(void)
+{
+	u32 mmu_base;
+	u32 *page_table = (u32 *)TOC0_MMU_BASE_ADDRESS;
+	int i;
+	u32 reg;
+
+	page_table[0] = (3 << 10) | (15 << 5) | (1 << 3) | (0 << 2) | 0x2;
+	/* the front 1G of memory(treated as 4G for all) is set up as none cacheable */
+	for (i = 1; i < (CONFIG_SYS_SDRAM_BASE>>20); i++)
+		page_table[i] = (i << 20) | (3 << 10) | (15 << 5) | (0 << 3) | 0x2;
+	/* Set up as write through and buffered(not write back) for other 3GB, rw for everyone */
+	for (i = (CONFIG_SYS_SDRAM_BASE>>20); i < 4096; i++)
+		page_table[i] = (i << 20) | (3 << 10) | (15 << 5) | (1 << 3) | (0 << 2) | 0x2;
+	/* flush tlb */
+	asm volatile("mcr p15, 0, %0, c8, c7, 0" : : "r" (0));
+	/* Copy the page table address to cp15 */
+	mmu_base = TOC0_MMU_BASE_ADDRESS;
+	mmu_base |= (1 << 0) | (1 << 1) | (2 << 3);
+	asm volatile("mcr p15, 0, %0, c2, c0, 0"
+		     : : "r" (mmu_base) : "memory");
+	asm volatile("mcr p15, 0, %0, c2, c0, 1"
+		     : : "r" (mmu_base) : "memory");
+	/* Set the access control to all-supervisor */
+	asm volatile("mcr p15, 0, %0, c3, c0, 0"
+		     : : "r" (0x55555555));			//modified, origin value is (~0)
+	asm volatile("isb");
+	/* and enable the mmu */
+	asm volatile("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (reg) : : "cc");
+
+	__usdelay(100);
+	reg |= (1 | (1<<12));    //enable mmu & icache
+	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR" : : "r" (reg) : "cc");
+	asm volatile("isb");
+
+
+}
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+void mmu_resetup(u32 dram_size, u32 reserved_size)
+{
+	u32 *page_table = (u32 *)TOC0_MMU_BASE_ADDRESS;
+	int i,j=0;
+	u32 pa_offset_start, va_offset_start;
+
+	pa_offset_start = (CONFIG_SYS_SDRAM_BASE>>20) + dram_size - reserved_size;
+	va_offset_start = CONFIG_SYS_OBLIGATE_BASE>>20;
+	/* Set up as write through and buffered(not write back) for other 3GB, rw for everyone */
+	for (i = va_offset_start; i < va_offset_start + reserved_size; i++, j++)
+		page_table[i] = ((pa_offset_start + j) << 20) | (3 << 10) | (15 << 5) | (1 << 3) | (0 << 2) | 0x2;
+	/* flush tlb */
+	asm volatile("mcr p15, 0, %0, c8, c7, 0" : : "r" (0));
+}
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+void  mmu_turn_off( void )
+{
+	uint reg;
+	/* and disable the mmu */
+	asm volatile("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (reg) : : "cc");
+	__usdelay(100);
+	reg &= ~((7<<0)|(1<<12));    //disable mmu & icache
+	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR" : : "r" (reg) : "cc");
+	asm volatile("isb");
+	/*
+	 * Invalidate all instruction caches to PoU.
+	 * Also flushes branch target cache.
+	 */
+	asm volatile ("mcr p15, 0, %0, c7, c5, 0" : : "r" (0));
+	/* Invalidate entire branch predictor array */
+	asm volatile ("mcr p15, 0, %0, c7, c5, 6" : : "r" (0));
+	/* Full system DSB - make sure that the invalidation is complete */
+	CP15DSB;
+	/* ISB - make sure the instruction stream sees it */
+	CP15ISB;
+}
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+u32 va2pa(u32 va)
+{
+    u32 pa;
+    asm volatile("mcr p15, 0, %0, c7, c8, 0\n"::"r"(va):"memory", "cc");
+
+
+    asm volatile("isb \n\t"
+                 " mrc p15, 0, %0, c7, c4, 0\n\t"
+                 : "=r" (pa) : : "memory", "cc");
+
+    return (pa & 0xfffff000) | (va & 0xfff);
+}
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/libs/nand_misc.c patched_uboot-sunxi-r16/sunxi_spl/sbrom/libs/nand_misc.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/libs/nand_misc.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/sbrom/libs/nand_misc.c	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,97 @@
+/*
+**********************************************************************************************************************
+*
+*						           the Embedded Secure Bootloader System
+*
+*
+*						       Copyright(C), 2006-2014, Allwinnertech Co., Ltd.
+*                                           All Rights Reserved
+*
+* File    :
+*
+* By      :
+*
+* Version : V2.00
+*
+* Date	  :
+*
+* Descript:
+**********************************************************************************************************************
+*/
+#include "common.h"
+#include "malloc.h"
+#include <private_toc.h>
+
+extern sbrom_toc0_config_t *toc0_config;
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+int BOOT_NandGetPara(void *param, uint size)
+{
+    memcpy( (void *)param, toc0_config->storage_data, size);
+
+	return 0;
+}
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+__u8  *get_page_buf( void )
+{
+
+	return (__u8 *)malloc(16 * 1024);
+}
+
+/*******************************************************************************
+*函数名称: g_mod
+*函数原型：uint32 g_mod( __u32 dividend, __u32 divisor, __u32 *quot_p )
+*函数功能: 从nand flash的某一块中找到一个完好备份将其载入到RAM中。如果成功，返
+*          回OK；否则，返回ERROR。
+*入口参数: dividend          输入。被除数
+*          divisor           输入。除数
+*          quot_p            输出。商
+*返 回 值: 余数
+*******************************************************************************/
+__u32 g_mod( __u32 dividend, __u32 divisor, __u32 *quot_p )
+{
+	if( divisor == 0 )
+	{
+		*quot_p = 0;
+		return 0;
+	}
+	if( divisor == 1 )
+	{
+		*quot_p = dividend;
+		return 0;
+	}
+
+	for( *quot_p = 0; dividend >= divisor; ++(*quot_p) )
+		dividend -= divisor;
+	return dividend;
+}
+
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/libs/sbrom_libs.h patched_uboot-sunxi-r16/sunxi_spl/sbrom/libs/sbrom_libs.h
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/libs/sbrom_libs.h	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/sbrom/libs/sbrom_libs.h	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,38 @@
+/*
+**********************************************************************************************************************
+*
+*						           the Embedded Secure Bootloader System
+*
+*
+*						       Copyright(C), 2006-2014, Allwinnertech Co., Ltd.
+*                                           All Rights Reserved
+*
+* File    :
+*
+* By      :
+*
+* Version : V2.00
+*
+* Date	  :
+*
+* Descript:
+**********************************************************************************************************************
+*/
+#ifndef  __SBORM_LIBS_H__
+#define  __SBORM_LIBS_H__
+
+
+extern void mmu_setup(void);
+void mmu_resetup(u32 dram_mbytes, u32 obligate_dram_mbytes);
+extern void mmu_turn_off(void);
+
+extern int create_heap(unsigned int pHeapHead, unsigned int nHeapSize);
+
+extern unsigned int go_exec (unsigned int run_addr, unsigned int para_addr, int out_secure);
+
+void boot0_jump(unsigned int addr);
+
+extern void set_debugmode_flag(void);
+
+#endif
+
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/libs/switch2ns.S patched_uboot-sunxi-r16/sunxi_spl/sbrom/libs/switch2ns.S
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/libs/switch2ns.S	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/sbrom/libs/switch2ns.S	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,86 @@
+/*
+**********************************************************************************************************************
+*
+*						           the Embedded Secure Bootloader System
+*
+*
+*						       Copyright(C), 2006-2014, Allwinnertech Co., Ltd.
+*                                           All Rights Reserved
+*
+* File    :
+*
+* By      :
+*
+* Version : V2.00
+*
+* Date	  :
+*
+* Descript:
+**********************************************************************************************************************
+*/
+#include "common.h"
+
+/*----------------------------------------------------------------------------*/
+/*   Description of SCR (Secure Configuration Register)                       */
+/*                                                                            */
+/*   |  bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0  |                     */
+/*   |  bit6 | AW   | FW   | EA   | FIQ  | IRQ  | NS    |                     */
+/*                                                                            */
+/*   AW  =0 the CPSR.A bit can be modified only in Secure state               */
+/*       =1 the CPSR.A bit can be modified in any security state              */
+/*                                                                            */
+/*   FW  =0 the CPSR.F bit can be modified only in Secure state               */
+/*       =1 the CPSR.F bit can be modified in any security state              */
+/*                                                                            */
+/*   EA  =0 Abort mode handles external aborts                                */
+/*       =1 Monitor mode handles external aborts                              */
+/*                                                                            */
+/*   FIQ =0 FIQ mode entered when FIQ is taken                                */
+/*       =1 Monitor mode entered when FIQ is taken                            */
+/*                                                                            */
+/*   IRQ =0 IRQ mode entered when IRQ is taken                                */
+/*       =1 Monitor mode entered when IRQ is taken                            */
+/*                                                                            */
+/*   NS  =0 Secure state                                                      */
+/*       =1 Non-secure state                                                  */
+/*                                                                            */
+/*----------------------------------------------------------------------------*/
+
+.globl secure_switch_unsecure
+
+secure_switch_unsecure:
+
+	mrc p15, 0, r2, c1, c1, 2
+	ldr r3, =(0xC00 | (0x03<<18))
+	orr r2, r2, r3
+	mcr p15, 0, r2, c1, c1, 2       @使能NSACR的CP11,CP10
+
+	mov r4, r0
+	cps #0x16		                @读取CPSR
+	msr spsr_cxsf, #0x13
+
+	mrc p15, 0, r5, c1, c1, 0
+    tst r5, #1
+    bne __switch_out
+
+    mov r0, #0x31		           @r0 = (1<<4 | 1<<3 | 1<<0);
+    mcr p15, 0, r0, c1, c1, 0
+
+	mov r0, #0			           @清理掉branch
+    mcr p15, 0, r0, c7, c5, 6
+
+__switch_out:
+	movs pc, r4
+
+
+.globl secure_switch_other
+
+secure_switch_other:
+
+	stmfd sp!, {r2, lr}
+	mov r2, r0
+	mov r0, r1
+
+	blx r2
+	ldmfd sp!, {r2, pc}
+
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/load/load_toc1_from_nand.c patched_uboot-sunxi-r16/sunxi_spl/sbrom/load/load_toc1_from_nand.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/load/load_toc1_from_nand.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/sbrom/load/load_toc1_from_nand.c	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,133 @@
+/*
+************************************************************************************************************************
+*                                                         eGON
+*                                         the Embedded GO-ON Bootloader System
+*
+*                             Copyright(C), 2006-2008, SoftWinners Microelectronic Co., Ltd.
+*											       All Rights Reserved
+*
+* File Name : load_Boot1_from_nand.c
+*
+* Author : Gary.Wang
+*
+* Version : 1.1.0
+*
+* Date : 2007.10.14
+*
+* Description : This file provides a function "load_Boot1_from_nand" to load a good copy of Boot1
+*             from outside nand flash chips to SRAM.
+*
+* Others : None at present.
+*
+*
+* History :
+*
+*  <Author>        <time>       <version>      <description>
+*
+* Gary.Wang       2007.10.14      1.1.0        build the file
+*
+************************************************************************************************************************
+*/
+#include "common.h"
+#include "spare_head.h"
+#include "private_toc.h"
+#include "asm/arch/nand_boot0.h"
+
+extern int verify_addsum( void *mem_base, __u32 size );
+/*******************************************************************************
+*函数名称: load_Boot1_from_nand
+*函数原型：int32 load_Boot1_from_nand( void )
+*函数功能: 将一份好的Boot1从nand flash中载入到SRAM中。
+*入口参数: void
+*返 回 值: 0                         载入并校验成功
+*          -1                        载入并校验失败
+*备    注:
+*******************************************************************************/
+int load_toc1_from_nand( void )
+{
+    __u32 i;
+    __s32  status;
+    __u32 length;
+    __u32 read_blks;
+	sbrom_toc1_head_info_t  *toc1_head;
+
+	if(NF_open( ) == NF_ERROR)                         // 打开nand flash
+	{
+		printf("fail in opening nand flash\n");
+
+		return -1;
+	}
+
+    for( i = BOOT1_START_BLK_NUM;  i <= BOOT1_LAST_BLK_NUM;  i++ )
+    {
+    	if( NF_read_status( i ) == NF_BAD_BLOCK )		// 如果当前块是坏块，则进入下一块
+    	{
+    		printf("nand block %d is bad\n", i);
+            continue;
+			}
+        /* 载入当前块最前面512字节的数据到SRAM中，目的是获取文件头 */
+        if( NF_read( i << ( NF_BLK_SZ_WIDTH - NF_SCT_SZ_WIDTH ), (void *)CONFIG_TOC1_STORE_IN_DRAM_BASE, 1 )  == NF_OVERTIME_ERR )
+        {
+		    printf("the first data is error\n");
+			continue;
+		}
+		/* 察看是否是文件头 */
+		toc1_head = (sbrom_toc1_head_info_t *) CONFIG_TOC1_STORE_IN_DRAM_BASE;
+		if(toc1_head->magic != TOC_MAIN_INFO_MAGIC)
+		{
+			printf("%s err: the toc1 head magic is invalid\n", __func__);
+			continue;
+		}
+        length =  toc1_head->valid_len;
+        if( ( length & ( ALIGN_SIZE - 1 ) ) != 0 )     // length必须是NF_SECTOR_SIZE对齐的
+        {
+            printf("the boot1 is not aligned by 0x%x\n", ALIGN_SIZE);
+        	continue;
+		}
+        if( 1==load_uboot_in_one_block_judge(length) )
+        {
+        	/* 从一个块中载入Boot1的备份 */
+        	status = load_and_check_in_one_blk( i, (void *)CONFIG_TOC1_STORE_IN_DRAM_BASE, length, NF_BLOCK_SIZE );
+        	if( status == ADV_NF_OVERTIME_ERR )            // 块数不足
+        	{
+        		continue;
+        	}
+        	else if( status == ADV_NF_OK )
+        	{
+                printf("Check is correct.\n");
+                NF_close( );                        // 关闭nand flash
+                return 0;
+            }
+        }
+        else
+        {
+        	/* 从多个块中载入一份Boot1的备份 */
+        	status = load_in_many_blks( i, BOOT1_LAST_BLK_NUM, (void*)CONFIG_TOC1_STORE_IN_DRAM_BASE,
+        								length, NF_BLOCK_SIZE, &read_blks );
+        	if( status == ADV_NF_LACK_BLKS )        // 块数不足
+        	{
+        		printf("ADV_NF_LACK_BLKS\n");
+        		NF_close( );                        // 关闭nand flash
+        		return -1;
+        	}
+        	else if( status == ADV_NF_OVERTIME_ERR )
+        	{
+        		printf("mult block ADV_NF_OVERTIME_ERR\n");
+        		continue;
+			}
+            if( verify_addsum( (__u32 *)CONFIG_TOC1_STORE_IN_DRAM_BASE, length ) == 0 )
+            {
+                printf("The file stored in start block %u is perfect.\n", i );
+                NF_close( );                        // 关闭nand flash
+                return 0;
+            }
+        }
+    }
+
+
+	printf("Can't find a good Boot1 copy in nand.\n");
+    NF_close( );                        // 关闭nand flash
+    printf("Ready to quit \"load_Boot1_from_nand\".\n");
+    return -1;
+}
+
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/load/Makefile patched_uboot-sunxi-r16/sunxi_spl/sbrom/load/Makefile
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/load/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/sbrom/load/Makefile	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,30 @@
+
+##
+## Makefile for Sunxi Secure Boot
+##
+
+
+
+include $(TOPDIR)/config.mk
+
+LIB	:= $(obj)libload.o
+
+COBJS-y += load_toc1_from_nand.o
+
+COBJS	:= $(COBJS-y)
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/main/brom.S patched_uboot-sunxi-r16/sunxi_spl/sbrom/main/brom.S
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/main/brom.S	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/sbrom/main/brom.S	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,101 @@
+
+
+#include "config.h"
+
+.globl _start
+_start: b	reset
+	ldr	pc, __nop
+	ldr	pc, __nop
+	ldr	pc, __nop
+	ldr	pc, __nop
+	ldr	pc, __nop
+	ldr	pc, __nop
+	ldr	pc, __nop
+
+reset:
+
+	ldr sp, =CONFIG_STACK_BASE
+	bl cpu_init_crit
+	bl clear_bss
+
+	bl sboot_memset
+	@bl system_mode
+	bl sbromsw_entry
+	b .
+
+__nop:
+	b __nop
+
+clear_bss:
+	ldr	r0, =__bss_start
+	ldr	r1, =__bss_end
+
+	mov	r2, #0x00000000		/* clear			    */
+
+clbss_l:
+	str	r2, [r0]		/* clear loop...		    */
+	add	r0, r0, #4
+	cmp	r0, r1
+	bne	clbss_l
+
+	mov pc, lr
+
+
+cpu_init_crit:
+
+	@Invalidate L1 I/D
+	mov	r0, #0			@ set up for MCR
+	mcr	p15, 0, r0, c8, c7,  0	@ invalidate TLBs
+	mcr	p15, 0, r0, c7, c5,  0	@ invalidate icache
+	mcr	p15, 0, r0, c7, c5,  6	@ invalidate BP array
+	mcr p15, 0, r0, c7, c10, 4	@ DSB
+	mcr p15, 0, r0, c7, c5,  4	@ ISB
+
+	@disable MMU stuff and caches
+	mrc	p15, 0, r0, c1, c0, 0
+	bic	r0, r0, #0x00002000	@ clear bits 13 (--V-)
+	bic	r0, r0, #0x00000007	@ clear bits 2:0 (-CAM)
+	orr	r0, r0, #0x00000800	@ set bit 11 (Z---) BTB
+	@enable I-cache
+	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-cache
+	mcr	p15, 0, r0, c1, c0, 0
+
+	mov pc, lr
+
+
+@system_mode:
+@
+@	ldr r0, =__int_vector_start
+@	add r1, r0, #0x20
+@
+@	mov r2, #CONFIG_SYS_INIT_RAM_ADDR
+@
+@copy_int_loop:
+@	ldmia   r0!, {r7-r8}
+@	stmia   r2!, {r7-r8}
+@	cmp     r0, r1
+@	blo     copy_int_loop
+@
+@	mov pc, lr
+
+sboot_memset:
+#if defined(CONFIG_ARCH_SUN8IW6P1)
+	mov r7, #0
+	mov r8, #0
+	mov r9, #0
+	mov r10, #0
+
+	mov r0, #0x1000
+
+	mov r2, #CONFIG_SYS_INIT_RAM_ADDR
+
+memset_loop:
+	stmia   r2!, {r7-r10}
+	sub     r0, r0, #16
+	cmp     r0, r1
+	blo     memset_loop
+
+	mov pc, lr
+#else
+	mov pc, lr
+#endif
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/main/Makefile patched_uboot-sunxi-r16/sunxi_spl/sbrom/main/Makefile
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/main/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/sbrom/main/Makefile	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,37 @@
+
+##
+## Makefile for Sunxi Secure Boot
+##
+
+
+
+include $(TOPDIR)/config.mk
+
+LIB	:= $(obj)libmain.o
+
+START	:= brom.o
+
+HEAD    := sbromsw_head.o
+DATA 	:= sbromsw_hash.o
+
+COBJS-y += sbrom_main.o
+COBJS-y += sbromsw_toc1.o
+
+SRCS	:= $(START:.o=.S) $(COBJS:.o=.c) $(HEAD:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(COBJS-y) $(SOBJS))
+HEAD	:= $(addprefix $(obj),$(HEAD) $(START))
+DATA	:= $(addprefix $(obj),$(DATA))
+
+all:	 $(obj).depend $(HEAD) $(START) $(LIB) $(DATA)
+
+$(LIB):	$(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/main/sbrom_main.c patched_uboot-sunxi-r16/sunxi_spl/sbrom/main/sbrom_main.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/main/sbrom_main.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/sbrom/main/sbrom_main.c	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,628 @@
+/*
+************************************************************************************************************************
+*                                          Boot rom
+*                                         Seucre Boot
+*
+*                             Copyright(C), 2006-2013, AllWinners Microelectronic Co., Ltd.
+*											       All Rights Reserved
+*
+* File Name   : Base.h
+*
+* Author      : glhuang
+*
+* Version     : 0.0.1
+*
+* Date        : 2013.09.05
+*
+* Description :
+*
+* Others      : None at present.
+*
+*
+* History     :
+*
+*  <Author>        <time>       <version>      <description>
+*
+* glhuang       2013.09.05       0.0.1        build the file
+*
+************************************************************************************************************************
+*/
+#include "common.h"
+#include "sbrom_toc.h"
+#include "boot_type.h"
+#include "openssl_ext.h"
+#include "asm/arch/clock.h"
+#include "asm/arch/ss.h"
+#include "asm/arch/timer.h"
+#include "asm/arch/uart.h"
+#include "asm/arch/rtc_region.h"
+#include "asm/arch/mmu.h"
+#include "asm/arch/gic.h"
+#include "private_toc.h"
+#include "sbrom_toc.h"
+#include "../libs/sbrom_libs.h"
+#include <asm/arch/dram.h>
+#include <private_toc.h>
+#ifdef CONFIG_BOOT_A15
+#include <asm/arch/cpu_switch.h>
+#endif
+
+extern void sid_read_rotpk(void *dst);
+extern void sunxi_certif_mem_reset(void);
+extern int sunxi_certif_probe_pubkey(X509 *x, sunxi_key_t *pubkey);
+extern void ndump(u8 *buf, int count);
+
+static void print_commit_log(void);
+static int sbromsw_toc1_traverse(void);
+//static int sbromsw_probe_fel_flag(void);
+static int sbromsw_clear_env(void);
+static int sunxi_root_certif_pk_verify(sunxi_certif_info_t *sunxi_certif, u8 *buf, u32 len);
+static int load_toc1_handler(int boot_type, int start_sector);
+static int sboot_check_uart_input(void);
+
+#ifdef SUNXI_OTA_TEST
+static int sbromsw_print_ota_test(void);
+#endif
+sbrom_toc0_config_t *toc0_config = (sbrom_toc0_config_t *)CONFIG_TOC0_CONFIG_ADDR;
+extern char sbromsw_hash_value[64];
+
+void sbromsw_entry(void)
+{
+	toc0_private_head_t *toc0 = (toc0_private_head_t *)CONFIG_SBROMSW_BASE;
+	uint dram_size;
+	int  ret, flag;
+	int boot_type;
+
+	timer_init();
+#ifndef CONFIG_ARCH_SUN8IW6P1
+	set_pll();
+#else
+	set_pll_for_secure();
+#endif
+	sunxi_serial_init(toc0_config->uart_port, toc0_config->uart_ctrl, 2);
+	set_debugmode_flag();
+	print_commit_log();
+	sboot_check_uart_input();
+	printf("try to probe rtc region\n");
+#ifdef SUNXI_OTA_TEST
+	sbromsw_print_ota_test();
+#endif
+	flag = rtc_region_probe_fel_flag();
+	printf("flag=0x%x\n", flag);
+	if(flag == SUNXI_RUN_EFEX_FLAG)
+	{
+		printf("sbromsw_entry sbromsw_probe_fel_flag\n");
+		rtc_region_clear_fel_flag();
+
+		goto __sbromsw_entry_err0;
+	}
+#ifdef CONFIG_BOOT_A15
+//	printf("toc0_config->boot_cpu=0x%x\n", toc0_config->boot_cpu);
+//	if(toc0_config->boot_cpu)
+//	{
+//		flag = BOOT_A7_FLAG;
+//	}
+//	else
+//	{
+//		flag = BOOT_A15_FLAG;
+//	}
+/*
+    boot_cpu  含义
+
+	bit0~7                       bit8~15
+
+	0:不需要保存标志位           1:当前应该切换a15启动
+	1:通知u-boot保存             0:当前应该切换a7启动
+
+	每次从brom读取的boot_cpu只能是0x100或者0
+*/
+
+	if(flag == BOOT_A15_FLAG)
+	{
+		rtc_region_clear_fel_flag();
+		if(toc0_config->boot_cpu == 0x00)
+			toc0_config->boot_cpu = 0x101;   //a15启动，需要保存标志位
+
+		switch_to_a15(toc0_config->a15_power_gpio);
+	}
+	else if(flag == BOOT_A7_FLAG)
+	{
+		rtc_region_clear_fel_flag();
+		if(toc0_config->boot_cpu == 0x100)      //如果原本是a15启动
+			toc0_config->boot_cpu = 0x01;       //a7启动，需要保存标志位
+	}
+	else
+	{
+		if(toc0_config->boot_cpu == 0x100)
+		{
+			switch_to_a15(toc0_config->a15_power_gpio);                //a15启动，不需要保存标志位
+		}
+		else
+		{
+			toc0_config->boot_cpu = 0x0;    //a7启动，不需要保存标志位
+		}
+	}
+    //printf("toc0_config->boot_cpu=0x%x\n", toc0_config->boot_cpu);
+#endif
+	printf("try to setup mmu\n");
+	//mmu init
+	mmu_setup();
+	printf("mmu setup ok\n");
+	//dram init
+	printf("try to init dram\n");
+	dram_size = init_DRAM(0, (void *)toc0_config->dram_para);
+	if (dram_size)
+	{
+		printf("init dram ok, size=%dM\n", dram_size);
+	}
+	else
+	{
+		printf("init dram fail\n");
+
+		goto __sbromsw_entry_err;
+	}
+	printf("mmu resetup\n");
+#ifndef CONFIG_OPTEE_SUPPORT	
+	mmu_resetup(dram_size, toc0_config->secure_dram_mbytes);
+#endif
+	printf("init heap\n");
+	create_heap(CONFIG_HEAP_BASE, CONFIG_HEAP_SIZE);
+	if(!toc0_config->secure_without_OS)
+        {
+	    printf("init gic\n");
+            gic_init();
+        }
+
+	boot_type = toc0->platform[0] & 0x0f;
+	printf("ss open\n");
+	sunxi_ss_open();
+	ret = load_toc1_handler(boot_type,UBOOT_START_SECTOR_IN_SDMMC);
+#ifdef CONFIG_TOC1_BACKUP_MODE
+	if(( ret !=0) &&
+	   (boot_type == BOOT_FROM_SD0 ||boot_type == BOOT_FROM_SD2 ))//only sdmmc support backup
+	{
+		ret = load_toc1_handler(boot_type,UBOOT_START_SECTOR_BACKUP_IN_SDMMC);
+	}
+#endif
+	printf("load status:%d\n",ret);
+
+__sbromsw_entry_err:
+#ifdef CONFIG_BOOT_A15
+	if(!(toc0_config->boot_cpu & 0xff00))
+	{
+		sbromsw_clear_env();
+
+		boot0_jump(SUNXI_FEL_ADDR_IN_SECURE);
+	}
+	else
+	{
+		rtc_region_set_flag(SUNXI_RUN_EFEX_FLAG);
+		sbromsw_clear_env();
+
+		watchdog_enable();
+	}
+#endif
+__sbromsw_entry_err0:
+	sbromsw_clear_env();
+
+	boot0_jump(SUNXI_FEL_ADDR_IN_SECURE);
+}
+
+static int load_toc1_handler(int boot_type, int start_sector)
+{
+	int ret;
+	printf("init flash\n");
+	ret = sunxi_flash_init(boot_type,start_sector);		//初始化外部介质，准备读取TOC1数据
+	if(ret)
+	{
+		printf("sbromsw_entry sunxi_flash_init failed\n");
+		return -1;
+	}
+	
+	ret = toc1_init();	//TOC1初始化，判断TOC1的头部是否合格
+	if(ret)
+	{
+		printf("sbromsw_entry toc1_init failed\n");
+		return -1;
+	}
+	ret = sbromsw_toc1_traverse();
+	if(ret)
+	{
+		printf("sbromsw_entry sbromsw_toc1_traverse failed\n");
+		return -1;
+	}
+	return 0;
+}
+
+static void print_commit_log(void)
+{
+        printf("sbrom commit : %s \n",sbromsw_hash_value);
+        return ;
+}
+
+#define  SUNXI_X509_CERTIFF_MAX_LEN   (4096)
+
+static int sbromsw_toc1_traverse(void)
+{
+	sbrom_toc1_item_group item_group;
+	int ret;
+	uint len, i;
+	u8 buffer[SUNXI_X509_CERTIFF_MAX_LEN];
+
+	sunxi_certif_info_t  root_certif;
+	sunxi_certif_info_t  sub_certif;
+	u8  hash_of_file[256];
+	//u8  hash_in_certif[256];
+
+	//u8  key_certif_extension[260];
+	//u8  content_certif_key[520];
+	int out_to_ns;
+    int ready_out_to_ns = 0;
+#ifdef CONFIG_OPTEE_SUPPORT	
+    uint optee_entry=0, uboot_entry=0;
+#endif
+	toc1_item_traverse();
+
+	printf("probe root certif\n");
+
+	memset(buffer, 0, SUNXI_X509_CERTIFF_MAX_LEN);
+	len = toc1_item_read_rootcertif(buffer, SUNXI_X509_CERTIFF_MAX_LEN);
+	if(!len)
+	{
+		printf("%s error: cant read rootkey certif\n", __func__);
+
+		return -1;
+	}
+
+	if(sunxi_root_certif_pk_verify(&root_certif, buffer, len))
+	{
+		printf("certif invalid: root certif verify itself failed\n");
+
+		return -1;
+	}
+
+	if(sunxi_certif_verify_itself(&root_certif, buffer, len))
+	{
+		printf("certif invalid: root certif verify itself failed\n");
+
+		return -1;
+	}
+	do
+	{
+		memset(&item_group, 0, sizeof(sbrom_toc1_item_group));
+		ret = toc1_item_probe_next(&item_group);
+		if(ret < 0)
+		{
+			printf("sbromsw_toc1_traverse err in toc1_item_probe_next\n");
+
+			return -1;
+		}
+		else if(ret == 0)
+		{
+			printf("sbromsw_toc1_traverse find out all items\n");
+#ifdef CONFIG_OPTEE_SUPPORT
+			printf("optee entry=0x%x\n", optee_entry);
+			printf("uboot entry=0x%x\n", uboot_entry);
+
+			if(optee_entry && uboot_entry)
+				go_exec(optee_entry, uboot_entry, SECURE_SWITCH_NORMAL);
+#endif
+			return 0;
+		}
+		if(item_group.bin_certif)
+		{
+			memset(buffer, 0, SUNXI_X509_CERTIFF_MAX_LEN);
+			len = toc1_item_read(item_group.bin_certif, buffer, SUNXI_X509_CERTIFF_MAX_LEN);
+			if(!len)
+			{
+				printf("%s error: cant read content key certif\n", __func__);
+
+				return -1;
+			}
+			//证书内容进行自校验，确保没有被替换
+			if(sunxi_certif_verify_itself(&sub_certif, buffer, len))
+			{
+				printf("%s error: cant verify the content certif\n", __func__);
+
+				return -1;
+			}
+//			printf("key n:\n");
+//			ndump(sub_certif.pubkey.n, sub_certif.pubkey.n_len);
+//			printf("key e:\n");
+//			ndump(sub_certif.pubkey.e, sub_certif.pubkey.e_len);
+			//每当发现一个公钥证书，即在根证书中寻找匹配项目，找不到则认为有错误
+			for(i=0;i<root_certif.extension.extension_num;i++)
+			{
+				if(!strcmp((const char *)root_certif.extension.name[i], item_group.bin_certif->name))
+				{
+					printf("find %s key stored in root certif\n", item_group.bin_certif->name);
+
+					if(memcmp(root_certif.extension.value[i], sub_certif.pubkey.n+1, sub_certif.pubkey.n_len-1))
+					{
+						printf("%s key n is incompatible\n", item_group.bin_certif->name);
+						printf(">>>>>>>key in rootcertif<<<<<<<<<<\n");
+						ndump((u8 *)root_certif.extension.value[i], sub_certif.pubkey.n_len-1);
+						printf(">>>>>>>key in certif<<<<<<<<<<\n");
+						ndump((u8 *)sub_certif.pubkey.n+1, sub_certif.pubkey.n_len-1);
+
+						return -1;
+					}
+					if(memcmp(root_certif.extension.value[i] + sub_certif.pubkey.n_len-1, sub_certif.pubkey.e, sub_certif.pubkey.e_len))
+					{
+						printf("%s key e is incompatible\n", item_group.bin_certif->name);
+						printf(">>>>>>>key in rootcertif<<<<<<<<<<\n");
+						ndump((u8 *)root_certif.extension.value[i] + sub_certif.pubkey.n_len-1, sub_certif.pubkey.e_len);
+						printf(">>>>>>>key in certif<<<<<<<<<<\n");
+						ndump((u8 *)sub_certif.pubkey.e, sub_certif.pubkey.e_len);
+
+						return -1;
+					}
+					break;
+				}
+			}
+			if(i==root_certif.extension.extension_num)
+			{
+				printf("cant find %s key stored in root certif", item_group.bin_certif->name);
+
+				return -1;
+			}
+		}
+
+		if(item_group.binfile)
+		{
+			//读出bin文件内容到内存
+			len = sunxi_flash_read(item_group.binfile->data_offset/512, (item_group.binfile->data_len+511)/512, (void *)item_group.binfile->run_addr);
+			//len = sunxi_flash_read(item_group.binfile->data_offset/512, (item_group.binfile->data_len+511)/512, (void *)0x2a000000);
+			if(!len)
+			{
+				printf("%s error: cant read bin file\n", __func__);
+
+				return -1;
+			}
+			//计算文件hash
+			memset(hash_of_file, 0, sizeof(hash_of_file));
+			ret = sunxi_sha_calc(hash_of_file, sizeof(hash_of_file), (u8 *)item_group.binfile->run_addr, item_group.binfile->data_len);
+			//ret = sunxi_sha_calc(hash_of_file, sizeof(hash_of_file), (u8 *)0x2a000000, item_group.binfile->data_len);
+			if(ret)
+			{
+				printf("sunxi_sha_calc: calc sha256 with hardware err\n");
+
+				return -1;
+			}
+			//使用内容证书的扩展项，和文件hash进行比较
+			//开始比较文件hash(小机端阶段计算得到)和证书hash(PC端计算得到)
+			if(memcmp(hash_of_file, sub_certif.extension.value[0], 32))
+			{
+				printf("hash compare is not correct\n");
+				printf(">>>>>>>hash of file<<<<<<<<<<\n");
+				ndump((u8 *)hash_of_file, 32);
+				printf(">>>>>>>hash in certif<<<<<<<<<<\n");
+				ndump((u8 *)sub_certif.extension.value[0], 32);
+
+				return -1;
+			}
+
+			printf("ready to run %s\n", item_group.binfile->name);
+            if(!toc0_config->secure_without_OS)
+            {
+                ready_out_to_ns = 1;
+            }
+            else
+            {
+                printf("secure_without_OS mode  \n");
+                ready_out_to_ns = 0;
+            }
+#ifdef CONFIG_OPTEE_SUPPORT
+            if(!strcmp(item_group.binfile->name, "optee"))
+            {
+            	optee_entry = item_group.binfile->run_addr;
+            }
+			else if(strcmp(item_group.binfile->name, "u-boot"))
+			{
+				out_to_ns = SECURE_SWITCH_OTHER;
+			}
+			else
+			{
+                if(!ready_out_to_ns)
+					out_to_ns = SECURE_NON_SECUREOS;
+                else
+                    out_to_ns = SECURE_SWITCH_NORMAL;
+                uboot_entry = item_group.binfile->run_addr;
+			}
+#else
+			if(strcmp(item_group.binfile->name, "u-boot"))
+			{
+                out_to_ns = SECURE_SWITCH_OTHER;
+			}
+			else
+			{
+                if(!ready_out_to_ns)
+					out_to_ns = SECURE_NON_SECUREOS;
+                else
+                    out_to_ns = SECURE_SWITCH_NORMAL;
+			}
+			toc0_config->next_exe_pa   = va2pa(item_group.binfile->run_addr);
+			go_exec(item_group.binfile->run_addr, CONFIG_TOC0_CONFIG_ADDR, out_to_ns);
+#endif			
+			
+		}
+	}
+	while(1);
+
+	return 0;
+}
+
+//static int sbromsw_probe_fel_flag(void)
+//{
+//	uint flag;
+//
+//	flag = rtc_region_probe_fel_flag();
+//	rtc_region_clear_fel_flag();
+//
+//	return flag;
+//}
+
+#ifdef SUNXI_OTA_TEST
+static int sbromsw_print_ota_test(void)
+{
+	printf("*********************************************\n");
+	printf("*********************************************\n");
+	printf("*********************************************\n");
+	printf("*********************************************\n");
+	printf("********[OTA TEST]:update toc0 sucess********\n");
+	printf("*********************************************\n");
+	printf("*********************************************\n");
+	printf("*********************************************\n");
+	printf("*********************************************\n");
+	return 0;
+}
+#endif
+
+static int sbromsw_clear_env(void)
+{
+#if defined(CONFIG_ARCH_SUN9IW1P1)
+	mctl_rst_securout();
+#endif
+	gic_exit();
+	reset_pll();
+	mmu_turn_off();
+
+	return 0;
+}
+
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+#define RSA_BIT_WITDH 2048
+static int sunxi_certif_pubkey_check( sunxi_key_t  *pubkey )
+{
+	char efuse_hash[256] , rotpk_hash[256];
+	char all_zero[32];
+
+	char pk[RSA_BIT_WITDH/8 * 2 + 256]; /*For the stupid sha padding */
+
+	sid_read_rotpk(efuse_hash);
+	memset(all_zero, 0, 32);
+	if( ! memcmp(all_zero, efuse_hash,32 ) )
+		return 0 ; /*Don't check if rotpk efuse is empty*/
+	else{
+		memset(pk, 0x91, sizeof(pk));
+		char *align = (char *)(((u32)pk+31)&(~31));
+		if( *(pubkey->n) ){
+			memcpy(align, pubkey->n, pubkey->n_len);
+			memcpy(align+pubkey->n_len, pubkey->e, pubkey->e_len);
+		}else{
+			memcpy(align, pubkey->n+1, pubkey->n_len-1);
+			memcpy(align+pubkey->n_len-1, pubkey->e, pubkey->e_len);
+		}
+
+		if(sunxi_sha_calc( (u8 *)rotpk_hash, 32, (u8 *)align, RSA_BIT_WITDH/8*2 ))
+		{
+			printf("sunxi_sha_calc: calc  pubkey sha256 with hardware err\n");
+			return -1;
+		}
+
+		if(memcmp(rotpk_hash, efuse_hash, 32)){
+			printf("certif pk dump\n");
+			ndump((u8 *)align , RSA_BIT_WITDH/8*2 );
+
+			printf("calc certif pk hash dump\n");
+			ndump((u8 *)rotpk_hash,32);
+
+			printf("efuse pk dump\n");
+			ndump((u8 *)efuse_hash,32);
+
+			printf("sunxi_certif_pubkey_check: pubkey hash check err\n");
+			return -1;
+		}
+		return 0 ;
+	}
+
+}
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :  buf: 证书存放起始   len：数据长度
+*
+*    return        :
+*
+*    note          :  证书自校验
+*
+*
+************************************************************************************************************
+*/
+static int sunxi_root_certif_pk_verify(sunxi_certif_info_t *sunxi_certif, u8 *buf, u32 len)
+{
+	X509 *certif;
+	int  ret;
+
+	//内存初始化
+	sunxi_certif_mem_reset();
+	//创建证书
+	ret = sunxi_certif_create(&certif, buf, len);
+	if(ret < 0)
+	{
+		printf("fail to create a certif\n");
+
+		return -1;
+	}
+	//获取证书公钥
+	ret = sunxi_certif_probe_pubkey(certif, &sunxi_certif->pubkey);
+	if(ret)
+	{
+		printf("fail to probe the public key\n");
+
+		return -1;
+	}
+	ret = sunxi_certif_pubkey_check(&sunxi_certif->pubkey);
+	if(ret){
+		printf("fail to check the public key hash against efuse\n");
+
+		return -1;
+	}
+
+	sunxi_certif_free(certif);
+
+	return 0;
+}
+int sboot_check_uart_input(void)
+{
+	int c = 0;
+	int i = 0;
+	for(i = 0;i < 3;i++)
+	{
+		__msdelay(10);
+		if(sunxi_serial_tstc())
+		{
+			printf("key press :");
+			c = sunxi_serial_getc();
+			printf("0x%x   \n",c-0x30); // ASCII to decimal digit
+			break;
+		}
+	}
+
+	if(c == '2')
+	{
+		printf("enter 0x%x,ready jump to fes\n", c-0x30);
+		sbromsw_clear_env();
+		boot0_jump(SUNXI_FEL_ADDR_IN_SECURE);
+	}
+	return 0;
+}
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/main/sbromsw_hash.c patched_uboot-sunxi-r16/sunxi_spl/sbrom/main/sbromsw_hash.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/main/sbromsw_hash.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/sbrom/main/sbromsw_hash.c	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,25 @@
+/*
+ * (C) Copyright 2007-2013
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Jerry Wang <wangflord@allwinnertech.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+ #include <common.h>
+ char sbromsw_hash_value[64] = {0x38};
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/main/sbromsw_head.c patched_uboot-sunxi-r16/sunxi_spl/sbrom/main/sbromsw_head.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/main/sbromsw_head.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/sbrom/main/sbromsw_head.c	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,92 @@
+/*
+************************************************************************************************************************
+*                                                         eGON
+*                                         the Embedded GO-ON Bootloader System
+*
+*                             Copyright(C), 2006-2008, SoftWinners Microelectronic Co., Ltd.
+*											       All Rights Reserved
+*
+* File Name : Boot0_head.c
+*
+* Author : Gary.Wang
+*
+* Version : 1.1.0
+*
+* Date : 2007.11.06
+*
+* Description : This file defines the file head part of Boot0, which contains some important
+*             infomations such as magic, platform infomation and so on, and MUST be allocted in the
+*             head of Boot0.
+*
+* Others : None at present.
+*
+*
+* History :
+*
+*  <Author>        <time>       <version>      <description>
+*
+* Gary.Wang       2007.11.06      1.1.0        build the file
+*
+************************************************************************************************************************
+*/
+#include "common.h"
+#include <private_boot0.h>
+#include <private_toc.h>
+extern char sbromsw_hash_value[64];
+
+const boot_file_head_t  sbromsw_head = {
+	      /* jump_instruction */          ( 0xEA000000 | ( ( ( sizeof( boot_file_head_t ) + sizeof(sbromsw_hash_value)+ sizeof( int ) - 1 ) / sizeof( int ) - 2 ) & 0x00FFFFFF ) ),
+							   		      TOC0_MAGIC,
+							   		      STAMP_VALUE,
+							   		      ALIGN_SIZE,
+							   		      sizeof( boot_file_head_t ),
+							   		      {
+							   		      	0, 0, 0, 0
+							   		      },
+							   		      CONFIG_TOC0_RET_ADDR,
+							   		      CONFIG_TOC0_RUN_ADDR,
+							   		      0,
+							   		      {
+							   		      	0, 0, '2','.','0','.','0',0
+							   		      },
+							 	  		};
+
+
+
+/*******************************************************************************
+*
+*                  关于Boot_file_head中的jump_instruction字段
+*
+*  jump_instruction字段存放的是一条跳转指令：( B  BACK_OF_Boot_file_head )，此跳
+*转指令被执行后，程序将跳转到Boot_file_head后面第一条指令。
+*
+*  ARM指令中的B指令编码如下：
+*          +--------+---------+------------------------------+
+*          | 31--28 | 27--24  |            23--0             |
+*          +--------+---------+------------------------------+
+*          |  cond  | 1 0 1 0 |        signed_immed_24       |
+*          +--------+---------+------------------------------+
+*  《ARM Architecture Reference Manual》对于此指令有如下解释：
+*  Syntax :
+*  B{<cond>}  <target_address>
+*    <cond>    Is the condition under which the instruction is executed. If the
+*              <cond> is ommitted, the AL(always,its code is 0b1110 )is used.
+*    <target_address>
+*              Specified the address to branch to. The branch target address is
+*              calculated by:
+*              1.  Sign-extending the 24-bit signed(wro's complement)immediate
+*                  to 32 bits.
+*              2.  Shifting the result left two bits.
+*              3.  Adding to the contents of the PC, which contains the address
+*                  of the branch instruction plus 8.
+*
+*  由此可知，此指令编码的最高8位为：0b11101010，低24位根据Boot_file_head的大小动
+*态生成，所以指令的组装过程如下：
+*  ( sizeof( boot_file_head_t ) + sizeof( int ) - 1 ) / sizeof( int )
+*                                              求出文件头占用的“字”的个数
+*  - 2                                         减去PC预取的指令条数
+*  & 0x00FFFFFF                                求出signed-immed-24
+*  | 0xEA000000                                组装成B指令
+*
+*******************************************************************************/
+
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/main/sbromsw_toc1.c patched_uboot-sunxi-r16/sunxi_spl/sbrom/main/sbromsw_toc1.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/main/sbromsw_toc1.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/sbrom/main/sbromsw_toc1.c	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,308 @@
+/*
+************************************************************************************************************************
+*                                          Boot rom
+*                                         Seucre Boot
+*
+*                             Copyright(C), 2006-2013, AllWinners Microelectronic Co., Ltd.
+*											       All Rights Reserved
+*
+* File Name   : SBromSW_TOC1.c
+*
+* Author      : glhuang
+*
+* Version     : 0.0.1
+*
+* Date        : 2014.03.07
+*
+* Description :
+*
+* Others      : None at present.
+*
+*
+* History     :
+*
+*  <Author>        <time>       <version>      <description>
+*
+* glhuang       2014.03.07       0.0.1        build the file
+*
+************************************************************************************************************************
+*/
+#include "common.h"
+#include "boot_type.h"
+#include "private_toc.h"
+#include "sbrom_toc.h"
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+static struct sbrom_toc1_head_info  *toc1_head = NULL;
+static struct sbrom_toc1_item_info  *toc1_item = NULL;
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+s32 toc1_init(void)
+{
+	toc1_head = (struct sbrom_toc1_head_info *)CONFIG_TOC1_STORE_IN_DRAM_BASE;
+	toc1_item = (struct sbrom_toc1_item_info *)(CONFIG_TOC1_STORE_IN_DRAM_BASE + sizeof(struct sbrom_toc1_head_info));
+
+	return 0;
+}
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+int toc1_item_traverse(void)
+{
+	int i;
+	struct sbrom_toc1_head_info  *p_head = toc1_head;
+	struct sbrom_toc1_item_info  *item_head = toc1_item;
+
+	printf("*******************TOC1 Head Message*************************\n");
+	printf("Toc_name          = %s\n",   p_head->name);
+	printf("Toc_magic         = 0x%x\n", p_head->magic);
+	printf("Toc_add_sum	      = 0x%x\n", p_head->add_sum);
+
+	printf("Toc_serial_num    = 0x%x\n", p_head->serial_num);
+	printf("Toc_status        = 0x%x\n", p_head->status);
+
+	printf("Toc_items_nr      = 0x%x\n", p_head->items_nr);
+	printf("Toc_valid_len     = 0x%x\n", p_head->valid_len);
+	printf("TOC_MAIN_END      = 0x%x\n", p_head->end);
+	printf("***************************************************************\n\n");
+
+	for(i=0;i<p_head->items_nr;i++,item_head++)
+	{
+		printf("\n*******************TOC1 Item Message*************************\n");
+		printf("Entry_name        = %s\n",   item_head->name);
+		printf("Entry_data_offset = 0x%x\n", item_head->data_offset);
+		printf("Entry_data_len    = 0x%x\n", item_head->data_len);
+
+		printf("encrypt	          = 0x%x\n", item_head->encrypt);
+		printf("Entry_type        = 0x%x\n", item_head->type);
+		printf("run_addr          = 0x%x\n", item_head->run_addr);
+		printf("index             = 0x%x\n", item_head->index);
+
+		printf("Entry_call        = 0x%x\n", item_head->run_addr);
+		printf("Entry_end         = 0x%x\n", item_head->end);
+		printf("***************************************************************\n\n");
+	}
+
+	return 0;
+}
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+uint toc1_item_read(struct sbrom_toc1_item_info *p_toc_item, void * p_dest, u32 buff_len)
+{
+	u32 to_read_blk_start = 0;
+	u32 to_read_blk_sectors = 0;
+	s32 ret = 0;
+
+	if( buff_len  < p_toc_item->data_len )
+	{
+		printf("PANIC : Toc1_item_read() error --1--,buff error\n");
+
+		return 0;
+	}
+
+	to_read_blk_start   = (p_toc_item->data_offset)>>9;
+	to_read_blk_sectors = (p_toc_item->data_len + 0x1ff)>>9;
+
+	ret = sunxi_flash_read(to_read_blk_start, to_read_blk_sectors, p_dest);
+	if(ret != to_read_blk_sectors)
+	{
+		printf("PANIC: toc1_item_read() error --2--, read error\n");
+
+		return 0;
+	}
+
+	return ret * 512;
+}
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+uint toc1_item_read_rootcertif(void * p_dest, u32 buff_len)
+{
+	u32 to_read_blk_start = 0;
+	u32 to_read_blk_sectors = 0;
+	s32 ret = 0;
+	struct sbrom_toc1_item_info *p_toc_item = toc1_item;
+
+	if( buff_len  < p_toc_item->data_len )
+	{
+		printf("PANIC : toc1_item_read_rootcertif() error --1--,buff error\n");
+
+		return 0;
+	}
+
+	to_read_blk_start   = (p_toc_item->data_offset)>>9;
+	to_read_blk_sectors = (p_toc_item->data_len + 0x1ff)>>9;
+
+	ret = sunxi_flash_read(to_read_blk_start, to_read_blk_sectors, p_dest);
+	if(ret != to_read_blk_sectors)
+	{
+		printf("PANIC: toc1_item_read_rootcertif() error --2--, read error\n");
+
+		return 0;
+	}
+
+	return ret*512;
+}
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :  成功：当前索引号>0   失败：找不到索引号，返回-1
+*
+*    note          :  自动获取下一个索引号对应的所有成员
+*                     如果失败，通常是索引到了尽头
+*
+************************************************************************************************************
+*/
+int toc1_item_probe_next(sbrom_toc1_item_group *item_group)
+{
+	struct sbrom_toc1_head_info  *p_head = toc1_head;
+	struct sbrom_toc1_item_info  *item_head;
+	char  *item_name = NULL;
+	int    i;
+
+	for(i=1; i<p_head->items_nr; i++)
+	{
+		item_head = toc1_item + i;
+
+		if(item_name != NULL)
+		{
+			if(!strcmp(item_name, item_head->name))
+			{
+				if(item_head->type == TOC_ITEM_ENTRY_TYPE_BIN_CERTIF)
+				{
+					if(item_group->bin_certif == NULL)
+					{
+						item_group->bin_certif = item_head;
+					}
+					else
+					{
+						printf("two bin certif with the same name %s\n", item_name);
+
+						return -1;
+					}
+				}
+				else if(item_head->type == TOC_ITEM_ENTRY_TYPE_BIN)
+				{
+					if(item_group->binfile == NULL)
+					{
+						item_group->binfile = item_head;
+					}
+					else
+					{
+						printf("two bin files with the same name %s\n", item_name);
+
+						return -1;
+					}
+				}
+				else
+				{
+					printf("unknown item type\n");
+
+					return -1;
+				}
+				item_head->reserved[0] = 1;
+
+				return 1;
+			}
+		}
+		else if(!item_head->reserved[0])
+		{
+			if(item_head->type == TOC_ITEM_ENTRY_TYPE_BIN_CERTIF)
+			{
+				item_group->bin_certif = item_head;
+			}
+			else if(item_head->type == TOC_ITEM_ENTRY_TYPE_BIN)
+			{
+				item_group->binfile = item_head;
+			}
+			else
+			{
+				printf("unknown item type\n");
+
+				return -1;
+			}
+			item_head->reserved[0] = 1;
+			item_name = item_head->name;
+		}
+	}
+
+	if(item_group->bin_certif == NULL)
+		return 0;
+	else
+		return 1;
+}
+
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/main/sbrom_toc.h patched_uboot-sunxi-r16/sunxi_spl/sbrom/main/sbrom_toc.h
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/main/sbrom_toc.h	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/sbrom/main/sbrom_toc.h	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,55 @@
+/*
+************************************************************************************************************************
+*                                          Boot rom
+*                                         Seucre Boot
+*
+*                             Copyright(C), 2006-2013, AllWinners Microelectronic Co., Ltd.
+*											       All Rights Reserved
+*
+* File Name   : Base.h
+*
+* Author      : glhuang
+*
+* Version     : 0.0.1
+*
+* Date        : 2013.09.05
+*
+* Description :
+*
+* Others      : None at present.
+*
+*
+* History     :
+*
+*  <Author>        <time>       <version>      <description>
+*
+* glhuang       2013.09.05       0.0.1        build the file
+*
+************************************************************************************************************************
+*/
+#ifndef	__SBROM_HW__H__
+#define	__SBROM_HW__H__
+
+#include "private_toc.h"
+//==============================================================================
+
+typedef struct
+{
+	struct sbrom_toc1_item_info  *key_certif;
+	struct sbrom_toc1_item_info  *bin_certif;
+	struct sbrom_toc1_item_info  *binfile;
+	struct sbrom_toc1_item_info  *normal;
+}sbrom_toc1_item_group;
+//===================================
+
+
+int toc1_init(void);
+int toc1_item_traverse(void);
+uint toc1_item_read(struct sbrom_toc1_item_info *p_toc_item, void * p_dest, u32 buff_len);
+
+uint toc1_item_read_rootcertif(void * p_dest, u32 buff_len);
+int toc1_item_probe_start(void);
+int toc1_item_probe_next(sbrom_toc1_item_group *item_group);
+
+
+#endif	//__SBROM_HW__H__
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/Makefile patched_uboot-sunxi-r16/sunxi_spl/sbrom/Makefile
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/sbrom/Makefile	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,107 @@
+#
+# (C) Copyright 2000-2011
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# (C) Copyright 2011
+# Daniel Schwierzeck, daniel.schwierzeck@googlemail.com.
+#
+# (C) Copyright 2011
+# Texas Instruments Incorporated - http://www.ti.com/
+# Aneesh V <aneesh@ti.com>
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Based on top-level Makefile.
+#
+
+include $(TOPDIR)/config.mk
+
+CONFIG_SPL := y
+export CONFIG_SPL
+
+SBROM_LDSCRIPT := $(TOPDIR)/sunxi_spl/sbrom/main/sboot.lds
+
+
+# We want the final binaries in this directory
+obj := $(OBJTREE)/sunxi_spl/sbrom/
+
+HEAD  := main/sbromsw_head.o
+START := main/brom.o
+
+LIBS-y += sunxi_spl/sbrom/spl/libsource_spl.o
+LIBS-y += sunxi_spl/sbrom/main/libmain.o
+LIBS-y += sunxi_spl/sbrom/libs/libgeneric.o
+LIBS-y += sunxi_spl/sbrom/flash/libflash.o
+LIBS-y += sunxi_spl/sbrom/load/libload.o
+LIBS-y += sunxi_spl/spl/lib/libgeneric.o
+LIBS-$(CONFIG_BOOT_A15) += arch/$(ARCH)/cpu/$(CPU)/$(SOC)/a15/liba15.o
+LIBS-y += arch/$(ARCH)/cpu/$(CPU)/$(SOC)/nand/libnand.o
+LIBS-y += arch/$(ARCH)/cpu/$(CPU)/$(SOC)/mmc/libmmc.o
+LIBS-y += arch/$(ARCH)/cpu/$(CPU)/$(SOC)/dram/libdram.o
+LIBS-$(CONFIG_SUNXI_CHIPID) += arch/$(ARCH)/cpu/$(CPU)/$(SOC)/dram/libchipid.o
+
+LIBS-y += lib/openssl/libopenssl.o
+
+
+LIBS := $(addprefix $(OBJTREE)/,$(sort $(LIBS-y)))
+
+
+__LIBS := $(subst $(obj),,$(LIBS))
+
+# Linker Script
+# ifdef CONFIG_SPL_LDSCRIPT
+# need to strip off double quotes
+# LDSCRIPT := $(addprefix $(SRCTREE)/,$(subst ",,$(CONFIG_SPL_LDSCRIPT)))
+# endif
+# ifeq ($(wildcard $(LDSCRIPT)),)
+# 	LDSCRIPT := $(TOPDIR)/board/$(BOARDDIR)/u-boot-spl.lds
+# endif
+# ifeq ($(wildcard $(LDSCRIPT)),)
+# 	LDSCRIPT := $(TOPDIR)/$(CPUDIR)/u-boot-spl.lds
+# endif
+# ifeq ($(wildcard $(LDSCRIPT)),)
+# $(error could not find linker script)
+# endif
+
+
+
+# Special flags for CPP when processing the linker script.
+# Pass the version down so we can handle backwards compatibility
+# on the fly.
+LDPPFLAGS += \
+	-include $(TOPDIR)/include/u-boot/u-boot.lds.h \
+	-DSBROMSWADDR=$(CONFIG_TOC0_RUN_ADDR)	 \
+	$(shell $(LD) --version | \
+	  sed -ne 's/GNU ld version \([0-9][0-9]*\)\.\([0-9][0-9]*\).*/-DLD_MAJOR=\1 -DLD_MINOR=\2/p')
+
+ALL-y	+= $(obj)sboot.bin
+
+all:	$(ALL-y)
+
+
+$(obj)sboot.bin:	$(obj)sboot.axf
+	$(OBJCOPY) $(OBJCFLAGS) -O binary $< $@
+
+GEN_UBOOT = \
+	UNDEF_SYM=`$(OBJDUMP) -x $(LIBS) | \
+	sed  -n -e 's/.*\($(SYM_PREFIX)__u_boot_cmd_.*\)/-u\1/p'|sort|uniq`;\
+	cd $(obj) && $(LD) $(LDFLAGS) -T$(obj)sboot.lds $(LDFLAGS_$(@F)) $$UNDEF_SYM  \
+	--start-group $(__LIBS) --end-group \
+	-Map sboot.map -o sboot.axf
+
+$(obj)sboot.axf: depend $(LIBS) $(obj)sboot.lds
+	$(LD) $(LIBS) $(PLATFORM_LIBGCC) $(LDFLAGS) -T$(obj)sboot.lds -o sboot.axf -Map sboot.map
+#	$(GEN_UBOOT)
+
+$(LIBS):	depend
+	$(MAKE) -C $(SRCTREE)$(dir $(subst $(OBJTREE),,$@))
+
+$(obj)sboot.lds: $(SBROM_LDSCRIPT)
+	$(CPP) $(CPPFLAGS) $(LDPPFLAGS) -ansi -D__ASSEMBLY__ -P - <$^ >$@
+
+depend:	$(obj).depend
+.PHONY: depend
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/spl/Makefile patched_uboot-sunxi-r16/sunxi_spl/sbrom/spl/Makefile
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/sbrom/spl/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/sbrom/spl/Makefile	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,59 @@
+#
+# (C) Copyright 2000-2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	=  $(obj)libsource_spl.o
+
+COBJS	+= $(TOPDIR)/arch/$(ARCH)/cpu/$(CPU)/$(SOC)/spl/rtc_region.o
+COBJS	+= $(TOPDIR)/arch/$(ARCH)/cpu/$(CPU)/$(SOC)/spl/timer_spl.o
+COBJS	+= $(TOPDIR)/arch/$(ARCH)/cpu/$(CPU)/$(SOC)/spl/gpio_spl.o
+COBJS	+= $(TOPDIR)/arch/$(ARCH)/cpu/$(CPU)/$(SOC)/spl/serial_spl.o
+COBJS	+= $(TOPDIR)/arch/$(ARCH)/cpu/$(CPU)/$(SOC)/spl/clock_spl.o
+COBJS	+= $(TOPDIR)/arch/$(ARCH)/cpu/$(CPU)/$(SOC)/spl/ss_spl.o
+COBJS	+= $(TOPDIR)/arch/$(ARCH)/cpu/$(CPU)/$(SOC)/spl/efuse_spl.o
+COBJS	+= $(TOPDIR)/arch/$(ARCH)/cpu/$(CPU)/$(SOC)/spl/smta_spl.o
+COBJS	+= $(TOPDIR)/arch/$(ARCH)/cpu/$(CPU)/$(SOC)/spl/smc_spl.o
+COBJS	+= $(TOPDIR)/arch/$(ARCH)/cpu/$(CPU)/$(SOC)/spl/gic_spl.o
+COBJS	+= $(TOPDIR)/arch/$(ARCH)/cpu/$(CPU)/$(SOC)/spl/debug.o
+COBJS	+= $(TOPDIR)/arch/$(ARCH)/cpu/$(CPU)/$(SOC)/spl/ctype.o
+COBJS	+= $(TOPDIR)/arch/$(ARCH)/cpu/$(CPU)/$(SOC)/spl/eabi_compat.o
+
+#COBJS-$(CONFIG_XXXX)	+= xxxx.o
+
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+all:	 $(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/spl/lib/console.c patched_uboot-sunxi-r16/sunxi_spl/spl/lib/console.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/spl/lib/console.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/spl/lib/console.c	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,286 @@
+/*
+**********************************************************************************************************************
+*
+*						           the Embedded Secure Bootloader System
+*
+*
+*						       Copyright(C), 2006-2014, Allwinnertech Co., Ltd.
+*                                           All Rights Reserved
+*
+* File    :
+*
+* By      :
+*
+* Version : V2.00
+*
+* Date	  :
+*
+* Descript:
+**********************************************************************************************************************
+*/
+#include <stdarg.h>
+#include <common.h>
+#include <asm/arch/uart.h>
+#include <private_boot0.h>
+
+#define  MASK_LOW4      0xf
+#define  NEGATIVE       1
+#define  POSITIVE       0
+#define  HEX_x          'x'
+#define  HEX_X          'X'
+
+int debug_mode = 1;
+/*
+******************************************************************************************************************
+*
+*Function Name : int_to_string_dec
+*
+*Description : This function is to convert an 'int' data 'input' to a string in decimalism, and the string
+*              converted is in 'str'.
+*
+*Input : int input : 'int' data to be converted.
+*        char * str : the start address of the string storing the converted result.
+*
+*Output : void
+*
+*call for :
+*
+*Others : None at present.
+*
+*******************************************************************************************************************
+*/
+void int_to_string_dec( int input , char * str)
+{
+	char stack[12];
+	char sign_flag = POSITIVE ;      // 'sign_flag indicates wheater 'input' is positive or negative, default
+	int i ;                           // value is 'POSITIVE'.
+	int j ;
+
+	if( input == 0 )
+	{
+		str[0] = '0';
+		str[1] = '\0';                   // 'str' must end with '\0'
+		return ;
+	}
+
+	if( input < 0 )                      // If 'input' is negative, 'input' is assigned to its absolute value.
+	{
+		sign_flag = NEGATIVE ;
+		input = -input ;
+	}
+
+	for( i = 0; input > 0; ++i )
+	{
+		stack[i] = input%10 + '0';      // characters in reverse order are put in 'stack' .
+		input /= 10;
+	}                                   // at the end of 'for' loop, 'i' is the number of characters.
+
+
+    j = 0;
+	if( sign_flag == NEGATIVE )
+		str[j++] = '-';		            // If 'input' is negative, minus sign '-' is placed in the head.
+	for( --i  ; i >= 0; --i, ++j )
+		str[j] = stack[i];
+	str[j] = '\0';				        // 'str' must end with '\0'
+
+	return;
+}
+
+
+void int_to_string_hex( int input, char * str )
+{
+	int i;
+	static char base[] = "0123456789abcdef";
+
+	for( i = 7; i >= 0; --i )
+	{
+		str[i] = base[input&MASK_LOW4];
+		input >>= 4;
+	}
+
+	str[8] = '\0';                        // 'str' must end with '\0'
+
+	return;
+}
+
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    函数名称：
+*
+*    参数列表：
+*
+*    返回值  ：
+*
+*    说明    ：
+*
+*
+************************************************************************************************************
+*/
+static __u32 mem_puts(const char *str, char *p )
+{
+    __u32 len = 0;
+
+	while( *str != '\0' )
+	{
+		if( *str == '\n' )                      // if current character is '\n', insert and output '\r'
+		{
+		    *p++ = '\r';
+		    len ++;
+        }
+        *p++ = *str++;
+        len ++;
+	}
+
+	return len;
+}
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+int vsprintf(char *buf, const char *fmt, va_list args)
+{
+	char string[16];
+	char *p, *q = buf;
+
+	while( *fmt )
+	{
+		if( *fmt == '%' )
+		{
+			++fmt;
+			p = string;
+			switch( *fmt )
+			{
+				case 'd': int_to_string_dec( va_arg( args, int), string );
+                          q += mem_puts( p, q );
+						  ++fmt;
+						  break;
+				case 'x':
+				case 'X': int_to_string_hex( va_arg( args,  int ), string );
+						  q += mem_puts( p, q );
+                          ++fmt;
+						  break;
+				case 'c': *q++ = va_arg( args,  __s32 );
+						  ++fmt;
+						  break;
+				case 's': q += mem_puts( va_arg( args, char * ), q );
+						  ++fmt;
+						  break;
+				default : *q++ = '%';                                    // if current character is not Conversion Specifiers 'dxpXucs',
+						  *q++ = *fmt++;                                 // output directly '%' and current character, and then
+						                                                 // let 'fmt' point to next character.
+			}
+		}
+		else
+		{
+			if( *fmt == '\n' )                      // if current character is '\n', insert and output '\r'
+				*q++ = '\r';
+
+            *q++ = *fmt++;
+		}
+	}
+
+    *q = 0;
+
+	return q-buf;
+}
+#ifndef CONFIG_SILENT
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+void puts(const char *s)
+{
+	char *src = (char *)s;
+	while (*src != '\0')
+		sunxi_serial_putc (*src++);
+}
+#endif
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+int sprintf(char * buf, const char *fmt, ...)
+{
+	va_list args;
+	int i;
+
+	va_start(args, fmt);
+	i=vsprintf(buf,fmt,args);
+	va_end(args);
+	return i;
+}
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+int (printf)(const char *fmt, ...)
+{
+	va_list args;
+	uint i;
+	char printbuffer[384];
+
+        if(!debug_mode)
+            return 0;
+	va_start(args, fmt);
+
+	/* For this to work, printbuffer must be larger than
+	 * anything we ever want to print.
+	 */
+	i = vsprintf(printbuffer, fmt, args);
+	va_end(args);
+
+	/* Print the string */
+	puts(printbuffer);
+	return i;
+}
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/spl/lib/jmp.c patched_uboot-sunxi-r16/sunxi_spl/spl/lib/jmp.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/spl/lib/jmp.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/spl/lib/jmp.c	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,46 @@
+/*
+**********************************************************************************************************************
+*
+*						           the Embedded Secure Bootloader System
+*
+*
+*						       Copyright(C), 2006-2014, Allwinnertech Co., Ltd.
+*                                           All Rights Reserved
+*
+* File    :
+*
+* By      :
+*
+* Version : V2.00
+*
+* Date	  :
+*
+* Descript:
+**********************************************************************************************************************
+*/
+#include "common.h"
+/*
+************************************************************************************************************
+*
+*                                             function
+*
+*    name          :
+*
+*    parmeters     :
+*
+*    return        :
+*
+*    note          :
+*
+*
+************************************************************************************************************
+*/
+void boot0_jump(unsigned int addr)
+{
+	asm volatile("mov r2, #0");
+    asm volatile("mcr p15, 0, r2, c7, c5, 6");
+
+	asm volatile("bx r0");
+}
+
+
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/spl/lib/Makefile patched_uboot-sunxi-r16/sunxi_spl/spl/lib/Makefile
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/spl/lib/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/spl/lib/Makefile	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,49 @@
+#
+# (C) Copyright 2000-2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	=  $(obj)libgeneric.o
+
+COBJS	+= console.o
+COBJS	+= string.o
+COBJS	+= jmp.o
+
+#COBJS-$(CONFIG_XXXX)	+= xxxx.o
+
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+all:	 $(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/spl/lib/string.c patched_uboot-sunxi-r16/sunxi_spl/spl/lib/string.c
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/spl/lib/string.c	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/spl/lib/string.c	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,242 @@
+/*
+ *  linux/lib/string.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+/*
+ * stupid library routines.. The optimized versions should generally be found
+ * as inline code in <asm-xx/string.h>
+ *
+ * These are buggy as well..
+ */
+
+#include <common.h>
+
+
+char * strcpy(char * dest,const char *src)
+{
+	char *tmp = dest;
+
+	while ((*dest++ = *src++) != '\0')
+		/* nothing */;
+	return tmp;
+}
+
+char * strncpy(char * dest,const char *src,size_t count)
+{
+	char *tmp = dest;
+
+	while (count-- && (*dest++ = *src++) != '\0')
+		/* nothing */;
+
+	return tmp;
+}
+
+char * strcat(char * dest, const char * src)
+{
+	char *tmp = dest;
+
+	while (*dest)
+		dest++;
+	while ((*dest++ = *src++) != '\0')
+		;
+
+	return tmp;
+}
+
+char * strncat(char *dest, const char *src, size_t count)
+{
+	char *tmp = dest;
+
+	if (count) {
+		while (*dest)
+			dest++;
+		while ((*dest++ = *src++)) {
+			if (--count == 0) {
+				*dest = '\0';
+				break;
+			}
+		}
+	}
+
+	return tmp;
+}
+
+int strcmp(const char * cs,const char * ct)
+{
+	register signed char __res;
+
+	while (1) {
+		if ((__res = *cs - *ct++) != 0 || !*cs++)
+			break;
+	}
+
+	return __res;
+}
+
+int strncmp(const char * cs,const char * ct,size_t count)
+{
+	register signed char __res = 0;
+
+	while (count) {
+		if ((__res = *cs - *ct++) != 0 || !*cs++)
+			break;
+		count--;
+	}
+
+	return __res;
+}
+
+char * strchr(const char * s, int c)
+{
+	for(; *s != (char) c; ++s)
+		if (*s == '\0')
+			return NULL;
+	return (char *) s;
+}
+
+size_t strlen(const char * s)
+{
+	const char *sc;
+
+	for (sc = s; *sc != '\0'; ++sc)
+		/* nothing */;
+	return sc - s;
+}
+
+
+char * strrchr(const char * s, int c)
+{
+       const char *p = s + strlen(s);
+       do {
+	   if (*p == (char)c)
+	       return (char *)p;
+       } while (--p >= s);
+       return NULL;
+}
+
+
+size_t strnlen(const char * s, size_t count)
+{
+	const char *sc;
+
+	for (sc = s; count-- && *sc != '\0'; ++sc)
+		/* nothing */;
+	return sc - s;
+}
+
+
+size_t strspn(const char *s, const char *accept)
+{
+	const char *p;
+	const char *a;
+	size_t count = 0;
+
+	for (p = s; *p != '\0'; ++p) {
+		for (a = accept; *a != '\0'; ++a) {
+			if (*p == *a)
+				break;
+		}
+		if (*a == '\0')
+			return count;
+		++count;
+	}
+
+	return count;
+}
+
+void * memset(void * s, int c, size_t count)
+{
+	char *xs = (char *) s;
+
+	while (count--)
+		*xs++ = c;
+
+	return s;
+}
+
+void * memcpy(void * dest,const void *src,size_t count)
+{
+	char *tmp = (char *) dest, *s = (char *) src;
+
+	while (count--)
+		*tmp++ = *s++;
+
+	return dest;
+}
+
+void * memmove(void * dest,const void *src,size_t count)
+{
+	char *tmp, *s;
+
+	if (dest <= src) {
+		tmp = (char *) dest;
+		s = (char *) src;
+		while (count--)
+			*tmp++ = *s++;
+		}
+	else {
+		tmp = (char *) dest + count;
+		s = (char *) src + count;
+		while (count--)
+			*--tmp = *--s;
+		}
+
+	return dest;
+}
+
+int memcmp(const void * cs,const void * ct,size_t count)
+{
+	const unsigned char *su1, *su2;
+	signed char res = 0;
+
+	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
+		if ((res = *su1 - *su2) != 0)
+			break;
+	return res;
+}
+
+/*
+ * find the first occurrence of byte 'c', or 1 past the area if none
+ */
+void * memscan(void * addr, int c, size_t size)
+{
+	unsigned char * p = (unsigned char *) addr;
+
+	while (size) {
+		if (*p == c)
+			return (void *) p;
+		p++;
+		size--;
+	}
+	return (void *) p;
+}
+
+char * strstr(const char * s1,const char * s2)
+{
+	int l1, l2;
+
+	l2 = strlen(s2);
+	if (!l2)
+		return (char *) s1;
+	l1 = strlen(s1);
+	while (l1 >= l2) {
+		l1--;
+		if (!memcmp(s1,s2,l2))
+			return (char *) s1;
+		s1++;
+	}
+	return NULL;
+}
+
+void *memchr(const void *s, int c, size_t n)
+{
+	const unsigned char *p = s;
+	while (n-- != 0) {
+		if ((unsigned char)c == *p++) {
+			return (void *)(p-1);
+		}
+	}
+	return NULL;
+}
diff -urN uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/spl/Makefile patched_uboot-sunxi-r16/sunxi_spl/spl/Makefile
--- uboot-sunxi-r16-267ce014d27c7fc13700e27f064f9c15e69e4bab/sunxi_spl/spl/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ patched_uboot-sunxi-r16/sunxi_spl/spl/Makefile	2022-10-17 16:23:17.919852169 +0000
@@ -0,0 +1,49 @@
+#
+# (C) Copyright 2000-2011
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# (C) Copyright 2011
+# Daniel Schwierzeck, daniel.schwierzeck@googlemail.com.
+#
+# (C) Copyright 2011
+# Texas Instruments Incorporated - http://www.ti.com/
+# Aneesh V <aneesh@ti.com>
+#
+# This file is released under the terms of GPL v2 and any later version.
+# See the file COPYING in the root directory of the source tree for details.
+#
+# Based on top-level Makefile.
+#
+
+include $(TOPDIR)/config.mk
+
+CONFIG_SPL := y
+export CONFIG_SPL
+
+# We want the final binaries in this directory
+obj := $(OBJTREE)/sunxi_spl/spl/
+
+
+LIBS-y += arch/$(ARCH)/cpu/$(CPU)/$(SOC)/spl/libsource_spl.o
+LIBS-$(CONFIG_STORAGE_MEDIA_MMC) += arch/$(ARCH)/cpu/$(CPU)/$(SOC)/mmc/libmmc.o
+LIBS-$(CONFIG_STORAGE_MEDIA_NAND) += arch/$(ARCH)/cpu/$(CPU)/$(SOC)/nand/libnand.o
+LIBS-y += arch/$(ARCH)/cpu/$(CPU)/$(SOC)/dram/libdram.o
+LIBS-$(CONFIG_SUNXI_CHIPID) += arch/$(ARCH)/cpu/$(CPU)/$(SOC)/dram/libchipid.o
+LIBS-y += lib/libgeneral.o
+
+LIBS := $(addprefix $(OBJTREE)/,$(sort $(LIBS-y)))
+
+ALL-y	+= $(obj)libspl.o
+
+all:	$(ALL-y)
+
+$(obj)libspl.o: depend $(LIBS)
+
+$(LIBS):	depend
+	$(MAKE) -C $(SRCTREE)$(dir $(subst $(OBJTREE),,$@))
+
+depend:	$(obj).depend
+.PHONY: depend
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
